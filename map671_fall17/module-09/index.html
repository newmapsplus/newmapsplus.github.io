<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
<title>Lesson 09: Advanced Mapping Techniques with CARTO</title>

</head>
<body>
<h1>Lesson 09: Advanced Mapping Techniques with CARTO</h1>

<h1>Table of Contents</h1>

<!-- MarkdownTOC autolink="true" autoanchor="true" bracket="round" depth=0  -->


<ul>
<li><a href="#lesson-09-overview">Lesson 09 Overview</a>

<ul>
<li><a href="#lesson-09-data-files">Lesson 09 Data files</a></li>
<li><a href="#example-map">Example Map</a></li>
</ul>
</li>
<li><a href="#filtering-and-manipulating-datasets-using-sql-in-carto">Filtering and manipulating datasets Using SQL in CARTO</a>

<ul>
<li><a href="#loading-point-level-data-into-carto">Loading point-level data into CARTO</a></li>
<li><a href="#using-the-select-sql-statement">Using the SELECT SQL statement</a></li>
<li><a href="#aggregating-records-by-field-values">Aggregating records by field values</a></li>
<li><a href="#extracting-unique-records-from-a-table">Extracting unique records from a table</a></li>
<li><a href="#attribute-joins-in-carto">Attribute Joins in CARTO</a></li>
</ul>
</li>
<li><a href="#symbolizing-point-data">Symbolizing point data</a>

<ul>
<li><a href="#builders-aggregation-functions">Builder's Aggregation functions</a></li>
<li><a href="#symbolizing-point-data-with-graduated-sizes-in-carto">Symbolizing point data with graduated sizes in CARTO</a>

<ul>
<li><a href="#creating-graduated-symbols-in-carto">Creating Graduated Symbols in CARTO</a></li>
<li><a href="#legends-with-graduated-symbols">Legends with graduated symbols</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#strategies-for-dealing-with-visual-information-overload">Strategies for dealing with visual information overload</a>

<ul>
<li><a href="#harnessing-zoom-levels-of-an-interactive-map-as-a-design-solution">Harnessing zoom levels of an interactive map as a design solution</a></li>
<li><a href="#performing-a-spatial-join-aka-point-in-polygon-in-carto">Performing a spatial join (aka point in polygon) in CARTO</a>

<ul>
<li><a href="#spatial-join-via-intersect-second-layer-analysis-function">Spatial Join via Intersect second layer analysis function</a></li>
<li><a href="#exporting-joined-datasets-and-updating-fields">Exporting joined datasets and updating fields</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#creating-a-multiscale-web-map-with-different-thematic-data-types">Creating a multiscale web map with different thematic data types</a>

<ul>
<li><a href="#controlling-zoom-level-visibility-with-cartocss">Controlling zoom level visibility with CartoCSS</a></li>
<li><a href="#finishing-up-the-web-map">Finishing up the web map</a></li>
</ul>
</li>
</ul>


<!-- /MarkdownTOC -->


<p><a name="lesson-09-overview"></a></p>

<h1>Lesson 09 Overview</h1>

<p>This lesson continues our exploration of CARTO. We'll use CARTO to symbolize point-level data of US Greenhouse Gas emissions as Graduated Symbols and use SQL in more depth. We'll then explore possibilities for bringing in another data layer and adjusting the visibility of these layers as the user zooms in and out of the map.</p>

<p><a name="lesson-09-data-files"></a></p>

<h2>Lesson 09 Data files</h2>

<ul>
<li><em>GHG_Emisisons_from_coal_2011-2015.csv</em></li>
</ul>


<p>Note: this dataset was downloaded from the <a href="http://ghgdata.epa.gov/ghgp/main.do">EPA's Facility Level Information on GreenHouse Gasses (GHG) Tool (FLIGHT)</a> and includes 2011-2015 Greenhouse Gas Emissions by facility from coal fuel.</p>

<p><a name="example-map"></a></p>

<h2>Example Map</h2>

<p><a href="https://nmp.carto.com/u/boyd/builder/70739b00-bbc3-11e6-8c9f-0e3ff518bd15/embed">Here is an example of a map you might produce with this lesson</a></p>

<p><a name="filtering-and-manipulating-datasets-using-sql-in-carto"></a></p>

<h1>Filtering and manipulating datasets Using SQL in CARTO</h1>

<p><a name="loading-point-level-data-into-carto"></a></p>

<h2>Loading point-level data into CARTO</h2>

<p>Let's first load a new dataset into our CARTO account. To begin, log in to CARTO and switch to view our datasets (e.g., https://nmp.CARTO.com/u/<em>username</em>/datasets).</p>

<p>Click on the New Dataset button, and select the <em>emissions_2014.csv</em> file that accompanies this module. Leave the option to let CARTO "automatically guess data types and content on import" checked. Click <strong>CONNECT DATASET</strong>.</p>

<p><img src="module-09-graphics/2016/connect-dataset.png" alt="Selecting the local data file and connecting the database to CARTO" /> <br/>
Figure 01: Selecting the local data file and connecting the database to CARTO</p>

<p>Once the dataset is connected, CARTO will open the file in the <strong>Table View</strong>. Take a moment to complete the metadata information.</p>

<p>Note that the <em>the_geom</em> column is populated with geometry values drawn from the latitude and longitude fields contained within the CSV file. CARTO automatically detected these values and georeferenced the data. How convenient!</p>

<p>Take a moment to scan through the rest of the field attributes. Note the one titled "ghg_quantity_metric_tons_co2e." This is a quantitive measure of the amount of reported greenhouse gasses emissions from coal fuel across the US between 2011 - 2015. It is a raw number (i.e., not a standardized rate) of a point location. The desired method for cartographically representing such data is a graduated or proportional symbol map.</p>

<p>First, we need to clean up and summarize our data. Switch over to the SQL tray in your <strong>Table View</strong>. Let's run some SQL commands to inspect our data.</p>

<p>Find the toggle switch with the help of this screen capture:</p>

<p><img src="module-09-graphics/2016/switch-on-sql-tray.png" alt="Table view and switch on SQL tray" />  <br/>
Figure 02: Table view and switching on the SQL tray</p>

<p><a name="using-the-select-sql-statement"></a></p>

<h2>Using the SELECT SQL statement</h2>

<p>Let's take a look at the default <strong>SELECT</strong> statement in the SQL tray:</p>

<pre><code>SELECT * FROM boyd.ghg_emisisons_from_coal
</code></pre>

<p>This statement selects all fields from the table called "ghg_emisisons_from_coal" in my account. We could easily filter out fields if we wanted to minimize the amount of data we had to manage down the design workflow. The only required fields are the "cartodb_id" (which provides interactivity such as popups) and "the_geom" (the spatial information for our features). Let's construct a statement that selects all records with the fields, "cartodb_id, the_geom, facility_name"</p>

<pre><code>SELECT 
    the_geom,
    cartodb_id,
    facility_name

FROM 
    boyd.ghg_emisisons_from_coal
</code></pre>

<p>SQL statements are case insensitive and can be formatted with line breaks and tabs for easier reading. The fields after the <code>select</code> should have commas separating them, except for the last field. Hit <strong>APPLY</strong> and notice that you should have three fields.</p>

<p>OK, let's inspect our data in more detail. Let's isolate only those facilities in your city or state. Run the following statement:</p>

<pre><code>SELECT * FROM 
    boyd.ghg_emisisons_from_coal
WHERE 
    city_name = 'LEXINGTON'
</code></pre>

<p>The <strong>WHERE</strong> clause filters records based on an expression. In this case we want only facilities in the city of Lexington. If we had two cities named "Lexington," we would add the <strong>AND</strong> operator:</p>

<pre><code>SELECT * FROM 
    boyd.ghg_emisisons_from_coal
WHERE 
    city_name = 'LEXINGTON' 
AND
    state = 'KY'
</code></pre>

<p>Since the fields "city_name" and "state" are a string datatype, we enclosed the value in single quotes. Note that string values are case sensitive. If your SQL statement was successful, you should have five years of data for the same facility. If we mapped this table now, many facilities would have five points.</p>

<p>Below is a screen capture of the above SQL statement:</p>

<p><img src="module-09-graphics/2016/unique-indentifier.png" alt="Finding the unique identifier" /> <br/>
Figure 03: Five records for the same facility as designated by the "ghgrp_id" field</p>

<p>If we wanted to map facilities by year, we just need to alter our <strong>WHERE</strong> clause to filter by year:</p>

<pre><code>SELECT * FROM 
    boyd.ghg_emisisons_from_coal
WHERE 
    reporting_year = 2015
ORDER BY 
    ghg_quantity_metric_tons_co2e DESC
</code></pre>

<p>The <code>ORDER BY</code> keyword sorts our table by greatest GHG emitters in descending order. The options for this keyword are ascending or descending order, e.g., <code>ORDER BY field_name ASC | DESC</code>. This statement helps us understand our data, but it also determines the order that symbols are drawn on the map. The first record is drawn first. If we created proportional circle symbols showing the amount of GHG, the largest emitters would not obscure the smaller emitters. OK, so we've got some familiarity with SQL. Let's use some of the SQL functions available in CARTO.</p>

<p><a name="aggregating-records-by-field-values"></a></p>

<h2>Aggregating records by field values</h2>

<p>What if we wanted to show emission amounts over the five years reported in the table? The math is simple; we would add up the the field "ghg_quantity_metric_tons_co2e" for each unique facility as shown in the "ghgrp_id" field. Let's see how this is done with SQL:</p>

<pre><code>/** sum metric tons by unique id **/
SELECT 
    SUM(ghg_quantity_metric_tons_co2e) as total_ghg, 
    ghgrp_id
FROM 
    boyd.ghg_emisisons_from_coal
GROUP BY 
    ghgrp_id
ORDER BY
    total_ghg DESC
</code></pre>

<p>The <code>SUM(numeric_field)</code> function works with the <code>GROUP BY</code> keyword to add up total emissions over the five-year reporting period for each unique facility as shown in the "ghgrp_id" field. Other aggregating statistical functions are <code>MAX(numeric_field)</code>, <code>MIN(numeric_field)</code>, <code>AVG(numeric_field)</code>, etc.</p>

<p>The <code>AS</code> keyword is field alias and creates a new field name in the output table. This is a screen capture of a successfully applied statement:</p>

<p><img src="module-09-graphics/2016/sum-function.png" alt="Successful statement to add up emission amounts per unique ID" /> <br/>
Figure 04: Successful statement to add up emission amounts per unique ID</p>

<p>Let's create a new dataset from this statement using the <strong>Create Dataset from query</strong>. We'll create a new table with these two fields. Since we have the "ghgrp_id," we can do attribute join back to the point layer for quantitative mapping. Find the command with the help of this screen capture:</p>

<p><img src="module-09-graphics/2016/new-dataset-from-query.png" alt="Create new dataset from query" /> <br/>
Figure 05: Create new dataset from query</p>

<p><a name="extracting-unique-records-from-a-table"></a></p>

<h2>Extracting unique records from a table</h2>

<p>Before we can do an attribute join to symbolize our new dataset, we'll need to extract the unique "ghgrp_id" records from our table. We can use the <strong>DISTINCT ON</strong> statement to extract unique records by a field value, i.e., "ghgrb_id". Since we have five years of reports for each facility (newer facilities might have fewer records), we need just one record from each facility. Let's take a look at the statement to understand what is happening:</p>

<pre><code>SELECT distinct on (ghgrp_id) 
    ghgrp_id,  
    facility_name, 
    parent_companies, 
    reported_address,
    city_name, 
    state, 
    the_geom
FROM 
    boyd.ghg_emisisons_from_coal
</code></pre>

<p>The first line <code>SELECT distinct on (ghgrp_id)</code> will select the first unique record for each instance of "ghgrb_id." The statement then adds the fields we've specified in the next few lines. Make sure to include "the_geom" since it contains the point location of our emitters. After you <strong>APPLY</strong> the statement, sort your table to make sure you don't have duplicates. When you are satisfied that you have a good table <strong>Create Dataset from query</strong> like we did in the previous step. Make sure you give it a unique name and metadata. You should have a screen that looks similar to the below capture:</p>

<p><img src="module-09-graphics/2016/select-distinct-on.png" alt="Create new dataset from DISTINCT ON statement" /> <br/>
Figure 06: Create new dataset from DISTINCT ON statement</p>

<p><a name="attribute-joins-in-carto"></a></p>

<h2>Attribute Joins in CARTO</h2>

<p>Before we begin our table join, let's make sure we have the correct layers. We should have the layer that adds up the metric tons of GHG per unique "ghgrb_id," which has two fields and no geometry. A second table should be essentially a list of different emitters, with location geometry.</p>

<p><img src="module-09-graphics/2016/list-of-tables-for-join.png" alt="Tables we created from the original dataset" /> <br/>
Figure 07: Tables we created from the original dataset</p>

<p>To start an attribute join in CARTO, we need to <strong>CREATE MAP</strong> from a layer. Let's use the layer we created from the <code>SELECT DISTINCT ON</code> statement, which has "the_geom" field. After we're in <strong>Map View</strong> we should <strong>ADD ANALYSIS</strong> for our layer as shown in this screen capture:</p>

<p><img src="module-09-graphics/2016/add-analysis.png" alt="Add Analysis to a layer" /> <br/>
Figure 08: Add Analysis to a layer in Map View</p>

<p>You will then be presented with a list of analysis functions that can be performed on our data. Most of the functions can be accomplished in SQL, but we'll save that for another lesson. Let's select the <strong>Join columns for a 2nd layer</strong> as shown below:</p>

<p><img src="module-09-graphics/2016/join-columns-analysis.png" alt="Join columns from 2nd layer" /> <br/>
Figure 09: Join columns from 2nd layer</p>

<p>The next steps will take more attention to detail.</p>

<ul>
<li>"Step 1 Your Workflow" shows the list of functions we could chain together.</li>
<li>"Step 2 Join columns from 2nd layer" allows us to specify the other table we want to join. The "JOIN TYPE" default is "Inner" which keeps only those records that match in both tables. The "Left" option keeps all records in target layer "A0" regardless if the records have a match in the join table.</li>
<li>"Step 3 Foreign Keys" allows you to select the join field in both tables. We know that it is "ghgrb_id."</li>
<li>"Step 4 Columns" allows you to select the fields you want to keep in the output table. The default is "0 selected" so be sure to add fields to both symbolize our data and to populated our pop-up windows with good information.</li>
</ul>


<p>A screen capture can't show all of the settings you'll need to apply, but it should look to this:</p>

<p><img src="module-09-graphics/2016/attribute-join.png" alt="Join columns from 2nd layer settings" /> <br/>
Figure 10: Join columns from 2nd layer settings in map view</p>

<p>Hit <strong>APPLY</strong> and CARTO will ask if you want to start styling your map. Of course! This is a new feature in <strong>Builder</strong> and what's nice about the <strong>Analysis</strong> functions is that they're editable, on-the-fly calculations. If you want to make a layer permanent, you'll need to <strong>Export dataset</strong> in the <strong>Layer options</strong> dialogue found to the next the layer's name.</p>

<p>OK, ready to <strong>STYLE</strong>? Change the <strong>FILL</strong> method to <strong>BY VALUE</strong> option and find the field that contains your total GHG emissions per facility between 2011-2015. It should have the prefix "right_" indicating that it was the join table. You should see something similar to the below screen capture:</p>

<p><img src="module-09-graphics/2016/graduated-color.png" alt="Defaults to graduated color not graduated size of marker" /> <br/>
Figure 11: Defaults to a graduated color, not a graduated size of marker</p>

<p><a name="symbolizing-point-data"></a></p>

<h1>Symbolizing point data</h1>

<p><a name="builders-aggregation-functions"></a></p>

<h2>Builder's Aggregation functions</h2>

<p>One of CARTO's most exciting features is the built-in aggregation function. Notice the slider in "Step 1 Aggregation" allows us to symbolize our data with a few different geography types. We can use standardize units (squares or hexbins) or units of administrative geographies, i.e., countries or states. Some important considerations and distinctions should be recognized before we use this approach. Most importantly, our <strong>POP-UP</strong> interactivity is not available with this aggregation methods. We also need to understand what the legend is doing in these various methods.</p>

<p>Let's take a look at the square and hexbin aggregation methods. Make the following settings for your layer:</p>

<ul>
<li>"Step 1 Aggregation" Select <strong>SQUARES</strong> method.</li>
<li>"Step 2 Aggregation Options" will allow you to do summary statistics on numeric fields just like we did with SQL in the earlier steps. Choose the <strong>SUM()</strong> function in the <strong>OPERATIONS</strong> selector and pick the field that contains your total GHG gas emissions per facility.</li>
</ul>


<p>You should produce a similar image to the screen capture:</p>

<p><img src="module-09-graphics/2016/aggregation-squares.png" alt="Aggregation by squares show total metric tons by arbitrary square sizes" />  <br/>
Figure 12: Aggregation by squares method show total metric tons by arbitrary square sizes</p>

<p>Notice that the legend has calculated a choropleth map dynamically from our joined table. Pretty cool. The hexbin aggregation method produces a similar map.</p>

<p>Perhaps the most useful aggregation method is by administrative unit. We can choose between "countries" or "provinces", but the legend will normalize the values based on the area of admin feature. Make the following settings for your layer:</p>

<ul>
<li>"Step 1 Aggregation" Select <strong>ADM. REGIONS</strong> method.</li>
<li>"Step 2 Aggregation Options" will allow you to do summary statistics on numeric fields just like we did with SQL in the earlier steps. Choose the <strong>SUM()</strong> function in the <strong>OPERATIONS</strong> selector and pick the field that contains your total GHG gas emissions per facility.</li>
</ul>


<p>You should produce a similar image to the screen capture:</p>

<p><img src="module-09-graphics/2016/aggregation-states.png" alt="Aggregation by provinces show total metric tons per square meter" />  <br/>
Figure 13: Aggregation by provinces show total metric tons per square meter</p>

<p>Besides changing the enumeration unit, this aggregation method dynamically calculates the density of emissions. The most important consideration is understanding the units portrayed in the legend. The default linear unit in CARTO (and PostgreSQL and PostGIS) is the meter. This method is normalizing by the area in square meters of provinces, aka states.</p>

<p><a name="symbolizing-point-data-with-graduated-sizes-in-carto"></a></p>

<h2>Symbolizing point data with graduated sizes in CARTO</h2>

<p>Let's vary the size of the point by an attribute. When aggregated by area, we lose the <strong>POP-UP</strong> functionality. To maintain the interactivity so cherished in web maps, we need to keep points. Maybe <strong>Builder</strong> will add a menu interface to create this type of symbology in the future. For now, we'll need to edit the CartoCSS to get graduated symbol sizes.</p>

<p>Graduated and proportional symbols are a useful alternative to choropleth maps and are used to map either total or ratio data. They have some important advantages over choropleth maps (i.e., the data need not be standardized). We can use true point data to make a proportional symbol map (such as the location of coal plant AND its total emissions), or conceptual point data (i.e., a wind farm covers a large area but we can still represent it as a point). These maps are also good at showing relative magnitudes (i.e., "I can tell that this one is larger than that one").</p>

<p>We can make graduated or proportional symbol maps but we'll need to tinker in CartoCSS. Graduated symbol maps are simply proportional symbol maps that use a series of class breaks. Currently, CARTO creates graduated symbol maps with its CartoCSS <strong>ramp()</strong> function on the <code>marker-width</code> property.</p>

<p><a name="creating-graduated-symbols-in-carto"></a></p>

<h3>Creating Graduated Symbols in CARTO</h3>

<p>Switch to the <strong>NONE</strong> for the Aggregation method and style the "FILL" with a solid color. Take the layer back to the default style as shown in this screen capture:</p>

<p><img src="module-09-graphics/2016/default-style.png" alt="Default style" />  <br/>
Figure 14: Default style with no aggregation or fill color by attribute value</p>

<p>Toggle over to the <strong>CartoCSS</strong> panel. You should see the following CartoCSS rules:</p>

<pre><code>#layer {
  marker-width: 7;
  marker-fill: #FFB927;
  marker-fill-opacity: 0.9;
  marker-allow-overlap: true;
  marker-line-width: 1;
  marker-line-color: #FFF;
  marker-line-opacity: 1;
}
</code></pre>

<p>The property <code>marker-width</code> property is set to a fixed size. We can vary the size of the marker by a numeric attribute if we employ the <strong>ramp()</strong> function. We saw this function in the last module, so let's fiddle with it some more.</p>

<p>Change the <code>marker-width</code> property to following expression: <code>marker-width: ramp([right_total_ghg], 7,60 );</code> and hit <strong>APPLY</strong>. Lot's of circles! What's happening here?</p>

<p>The marker's width is varied between 7 pixels and 60 pixels proportionally based on the values in the field "right_total_ghg." You could use the classification methods like 'jenks', 'quantiles', or 'equal' interval methods, too. The 'jenks' and the other classification methods are enclosed in quotes because they string values. Only numeric values can be used without quotes.</p>

<p>Experiment with your CartoCSS rules, such as with color, opacity, and line width. Below is an example map with unique CartoCSS properties:</p>

<p><img src="module-09-graphics/2016/graduated-symbols.png" alt="Example of graduated symbols" />  <br/>
Figure 14: Example of graduated symbols using Jenks classification method</p>

<pre><code>#layer {
  marker-width: ramp([right_total_ghg], 7,60,'jenks');
   marker-fill:#FFB927;
  marker-fill-opacity: 0.4;
  marker-allow-overlap: true;
  marker-line-width: 1;
  marker-line-color: #FFF;
  marker-line-opacity: 1;
}
</code></pre>

<p><a name="legends-with-graduated-symbols"></a></p>

<h3>Legends with graduated symbols</h3>

<p>Unfortunately, dynamic legend generation doesn't work yet in <strong>Builder</strong> with custom CartoCSS rules. We can always add a custom legend via the <strong>LEGEND</strong> panel and give appropriate helpful text descriptions. Consider this legend for a graduated symbol map:</p>

<p><img src="module-09-graphics/2016/custom-legend.png" alt="Example of custom legend for graduated symbols" />  <br/>
Figure 15: Example of custom legend for graduated symbols</p>

<p>Before we continue, let's <strong>Export data</strong> for this layer with the attribute join so we can reuse it on other CARTO maps. Much like in QGIS, the attribute join is an on-the-fly join that only exists within a map. To make it permanent we'll need to <strong>Export data</strong> as shown in the below screen capture. Unfortunately, we'll need to cycle through download/upload with this exported dataset to use in CARTO. Perhaps future iterations will allow saving the layer directly into a user's <strong>Datasets</strong> dashboard.</p>

<p><img src="module-09-graphics/2016/export-emissions-by-facility.png" alt="Export data to new dataset " />  <br/>
Figure 16: Export data to new dataset</p>

<p>Select <strong>GeoJSON</strong> as the preferred file format. Avoid using Shapefiles since this format will truncate column names.</p>

<p><img src="module-09-graphics/2016/export-dataset.png" alt="Export joined datasets to a new GeoJSON " />  <br/>
Figure 17: Export joined datasets to a new GeoJSON</p>

<p>Download the dataset and connect it back into CARTO. Before you upload the dataset, change the name of the GeoJSON file to a unique name, such as "GHG-emissions-by-coal-facility.geojson" The default name is the name of point layer we used in the table join analysis.</p>

<p>Keep this layer on hold for now. We'll use in the final map production section of the module.</p>

<p><a name="strategies-for-dealing-with-visual-information-overload"></a></p>

<h1>Strategies for dealing with visual information overload</h1>

<p><a name="harnessing-zoom-levels-of-an-interactive-map-as-a-design-solution"></a></p>

<h2>Harnessing zoom levels of an interactive map as a design solution</h2>

<p>While we can play with the visual design of the symbols (adjust their size and appearance), another potential solution within web maps we don't have in static maps lies in the ability to zoom into the map.</p>

<p>Notice that the sizes of the graduate point symbols re-adjust when zooming in and out of the map. Because of the density of the facility points, the map is fairly legible when zoomed in, but not so much when zoomed out.</p>

<p>Users can easily make visual comparisons between the facilities when zoomed into the map (say, zoom level 6 or greater). But what can we do when zoomed out (let's say zoom levels less than 6)? Notice that the zoom level is shown in the lower-left corner of the map. We can use zoom levels in CartoCSS as a condition. While we'll return to this option later in the module, try the following CartoCSS:</p>

<pre><code>/* turn a layer on after a zoom level is reached */

#layer [zoom &gt; 6 ] {
   marker-width: ramp([right_total_ghg], 7,60);
  marker-fill: #FFB927;
  marker-fill-opacity: 0.4;
  marker-allow-overlap: true;
  marker-line-width: 1;
  marker-line-color: #FFF;
  marker-line-opacity: 0.6;
}
</code></pre>

<p>The remainder of this module will test a design solution. Our aim is to display the data using different visualization techniques at different zoom levels, i.e., points when zoomed and polygons when zoomed out. We've seen that we can aggregate point data by different areas and geographies, such as by hexbin or states. What if we wanted to aggregate by a different level of geography not found in the <strong>STYLE</strong> methods presented in CARTO? And, finally, can we switch between the different techniques on the same map?</p>

<p><a name="performing-a-spatial-join-aka-point-in-polygon-in-carto"></a></p>

<h2>Performing a spatial join (aka point in polygon) in CARTO</h2>

<p>Let's say we wanted to find the total greenhouse gasses emitted per county? While we could bring these point-level data down into QGIS and do a spatial join or point-in-polygon analysis using US states before pushing it back up to CARTO, we can also do this directly within the CARTO web interface. The <strong>ANALYSIS</strong> panel offers such a function, <strong>Intersect second layer</strong> which calculates aggregations dynamically.</p>

<p>First, let's get some US counties polygons. Again, let's go to the US Census Cartographic Boundary files and this time import the US counties at 1:500,000-scale (<a href="http://www2.census.gov/geo/tiger/GENZ2015/shp/cb_2015_us_county_500k.zip">http://www2.census.gov/geo/tiger/GENZ2015/shp/cb_2015_us_county_500k.zip</a>). Remember we can import these directly into CARTO without first downloading to our local machine (refer to the instructions in module 08).</p>

<p>Once the data is loaded, <strong>CREATE MAP</strong> and open the layer in <strong>MAP VIEW</strong>. For an extra challenge, do an <strong>Attribute Join</strong> using the 2010 population by county dataset we used in Lab 02.</p>

<p><img src="module-09-graphics/2016/county-population.png" alt="Adding county polygons with an attribute join" /> <br/>
Figure 18: Adding county polygons with an attribute join of county population counts</p>

<p>You might remember that this type of choropleth map isn't the best way to present raw counts of data. We'll normalize our data after we commit the spatial join. Let's take a look at our attribute table before the spatial join. To normalize our data after the join we could use the column "aland" (land area in square meters) and if you committed an attribute join you could also use the columns "right_pop2010" and "right_sqmi". What we're looking to create is a column that shows the  total amount of GHG emitted in each county from 2011 - 2015.</p>

<p><img src="module-09-graphics/2016/columns-before-spatial-join.png" alt="Field names in county polygons before spatial join that could be used to normalize our data" /> <br/>
Figure 19: Field names in county polygons before spatial join that could be used to normalize our data</p>

<p><a name="spatial-join-via-intersect-second-layer-analysis-function"></a></p>

<h3>Spatial Join via Intersect second layer analysis function</h3>

<p>Begin in top <strong>Map View</strong> that shows your list of layers on the map. Click on the <strong>ADD ANALYSIS</strong> link as shown below:</p>

<p><img src="module-09-graphics/2016/add-analysis-spatial-join.png" alt="Start spatial join with polygon layer" /> <br/>
Figure 20: Start spatial join with polygon layer</p>

<p>Next, select <strong>Intersect second layer analysis function</strong>:</p>

<p><img src="module-09-graphics/2016/add-intersect-layer.png" alt="Intersect second layer analysis function" /> <br/>
Figure 21: Intersect second layer analysis function</p>

<p>After your click on <strong>ADD ANALYSIS</strong> you will arrive at <strong>Your workflow</strong> for this layer with a chain of analyses. For this analysis, you need to choose the <strong>INTERSECT LAYER</strong> that contains your attribute for GHG emissions, <em>ghg_emissions_from_coal</em> or the layer with created with SQL earlier called <em>ghg_emssions_coal_sum</em>.</p>

<p>In the <strong>Measure by</strong> step, select the <strong>OPERATION</strong> that adds up our emissions, <strong>SUM(ghg_quantity_metric_tons_co2e)</strong> or <strong>SUM(total_ghg)</strong>, depending on which layer you are intersecting. It doesn't matter which layer you choose since the intersect will arrive at the same solution. Your CARTO settings should look similar to the following:</p>

<p><img src="module-09-graphics/2016/intersect-analysis.png" alt="Intersect second layer analysis settings" /> <br/>
Figure 22: Intersect second layer analysis settings</p>

<p>Hit <strong>APPLY</strong> and if you have success, you should have the following message showing the column added to our map.</p>

<p><img src="module-09-graphics/2016/success.png" alt="Intersect second layer analysis success" /> <br/>
Figure 23: A successful intersect will show the added column name</p>

<p>Click on <strong>STYLE THIS ANALYSIS</strong> and change the polygon <strong>FILL</strong> method to <strong>BY VALUE</strong> and use the added column name. You'll immediately notice not all counties are included in the analysis. A "NULL" output (a county without emitters) is not included in the output geometry.</p>

<p>Most importantly, there's one problem with this map. Unfortunately, CARTO still allows us to do cartographically silly things, like create a choropleth map of un-normalized data. We have raw count of emissions by metric tons though we cannot normalize the quantity in the <strong>STYLE</strong> Panel. The new version of CARTO offers these remarkable on-the-fly analysis methods, which can be modified easily, but we cannot do the same type manipulations we've learned in QGIS.</p>

<p><img src="module-09-graphics/2016/raw-count-of-emissions.png" alt="Raw count of emissions isn't normalized" /> <br/>
Figure 24: Raw count of emissions isn't normalized</p>

<p>To make this map more honest, we should divide those raw GHG totals by another number (in this case, the area of the land or population makes sense). We already know how to do this within QGIS using the field calculator, and that's certainly one option for us here. This would require:</p>

<ol>
<li>importing the merged dataset into QGIS using the CARTO plugin</li>
<li>saving the imported file as a local Shapefile</li>
<li>using the field calculator to make the calculation and save into a new field</li>
<li>saving the changes to that shapefile</li>
<li>exposing the new shapefile from QGIS back to CARTO</li>
</ol>


<p>There's nothing wrong with this workflow. But wouldn't it be nice if we could just do that quickly here in CARTO? That's where the usefulness of knowing a little SQL comes in.</p>

<p><a name="exporting-joined-datasets-and-updating-fields"></a></p>

<h3>Exporting joined datasets and updating fields</h3>

<p>Since this layer contains a workflow of analyses, we'll need to <strong>Export data</strong> the dataset to a new layer before we can use SQL. Unfortunately, we'll need to cycle through download/upload with this exported dataset to use in CARTO. Perhaps future iterations will allow saving the layer directly into a user's <strong>Datasets</strong> dashboard.</p>

<p>Find the layer's option button dropdown and select <strong>Export data</strong> as shown below:</p>

<p><img src="module-09-graphics/2016/export-data.png" alt="Export data to new dataset" /> <br/>
Figure 25: Export data to new dataset</p>

<p>Select <strong>GeoJSON</strong> as the preferred file format. Avoid using Shapefiles since this format will truncate column names. Download the dataset and connect it back into CARTO. Before you upload the dataset, you might consider changing the name of the GeoJSON file to a unique name, such as "ghg-emissions-by-county-and-population.geojson" The default name is the name of polygon layer we used in the intersect analysis.</p>

<p>After you connect the new dataset, open the attribute table, toggle on the SQL tray, and inspect the columns. You should see something like below:</p>

<p><img src="module-09-graphics/2016/ghg-emissions-output-table.png" alt="Emissions by county and population table" /> <br/>
Figure 26: Emissions by county and population table</p>

<p>As we learned earlier in the lesson, we can use SQL to gain knowledge about our data. For example, which county had the most emissions? Use the following statement in the SQL tray:</p>

<pre><code>SELECT 
    * 
FROM 
    boyd.ghg_emissions_by_county_and_population
ORDER BY 
    sum_ghg_quantity_metric_tons_co2e DESC
</code></pre>

<p>Let's normalize our data by the size of the county and by population. First, we need to create two new fields. Hit <strong>CLEAR</strong> in your SQL tray to remove any custom statements. Then find the <strong>ADD COLUMN</strong> link in the table's upper-right corner:</p>

<p><img src="module-09-graphics/2016/add-field.png" alt="Add new column in Table View" /> <br/>
Figure 27: Add new column in Table View</p>

<p>Name the first new column something like "ghg_normalized_by_area" and change the type to be a number type. If you have joined population to the table, add a second field and call it "ghg_normalized_by_population" and change the type to be a number type.</p>

<p>OK, let's try some calculate some new fields. We're going to apply an SQL query to our dataset that's going to update the existing table and assign new values within our newly created "ghg_normalized_by_area" field. Divide our "sum_ghg_quantity_metric_tons_co2e" field by our "aland" field (this is essentially the same thing we're doing using the field calculator in QGIS). Here is the SQL statement:</p>

<pre><code>UPDATE 
    boyd.ghg_emissions_by_county_and_population
SET 
    ghg_normalized_by_area = sum_ghg_quantity_metric_tons_co2e/aland
</code></pre>

<p>However, applying this query will not yield the result we are hoping to get. We can see the values in the "ghg_normalized_by_area" column are all zeros (not what we expected). The reason for this is that CARTO is using a <a href="http://www.postgresql.org/">PostgreSQL</a> database to do this calculation, and when PostgreSQL divides two integers it chops off the remainder (not very helpful indeed!).</p>

<p>To correct this problem we need to convert one of these field values to a floating point data type upon the calculation. We do this by applying the <code>::float</code> switch to our field value. This forces the calculation to a floating point output.</p>

<pre><code>UPDATE 
    boyd.ghg_emissions_by_county_and_population
SET 
    ghg_normalized_by_area = sum_ghg_quantity_metric_tons_co2e::float/aland
</code></pre>

<p>Applying this query yields are anticipated results, but let's take a moment to reflect on these calculated data values. We're dividing tons of metric GHG emissions by the area of land (the cartographic boundary file encodes area in square meters within the "aland" field). A more meaningful measure would be to calculate the amount of GHG per square kilometer. To do this, we can easily divide the values of "aland" by 1,000,000 to get square kilometers.</p>

<p>We thereby update our SQL query to be (we write 1000000.0 and omit the <code>::float</code> switch. Either will avoid the division by integers problem):</p>

<pre><code>UPDATE 
    boyd.ghg_emissions_by_county_and_population
SET 
    ghg_normalized_by_area = sum_ghg_quantity_metric_tons_co2e/(aland/1000000.0)
</code></pre>

<p>OK, one last issue. If we created a <strong>POP-UP</strong> using the "ghg_normalized_by_area" field, we would have too many decimal places. Let's employ the <code>round()</code> function to round to one decimal place. The format for a properly constructed function is:</p>

<p><code>round(numeric value, integer giving number of decimal places)</code></p>

<p>Apply this statement in your SQL try:</p>

<pre><code>UPDATE 
    boyd.ghg_emissions_by_county_and_population
SET 
    ghg_normalized_by_area = round((sum_ghg_quantity_metric_tons_co2e/(aland/1000000.0))::numeric,1)
</code></pre>

<p>We can do math inside functions and just remember to use parentheses to group your expressions. The <code>::numeric</code> switch is used to signal to the <code>round()</code> function the expression will evaluate to a number. The last parameter is an integer giving number of decimal places.</p>

<p>Now our "ghg_normalized_by_area" field is populated with more meaningful numbers, and we can anticipate adding map and legend titles to the effect of "Metric tons of GHG per square kilometer."</p>

<p>If you have population by county, try to calculate the "ghg_normalized_by_population" field. It's the same procedure as above, just different fields. Remember to use the <code>::float</code> switch to ensure you get fractional values as output.</p>

<p>Before you continue with the final stages of the module, order your table by "ghg_normalized_by_area"</p>

<pre><code>SELECT 
    * 
FROM 
    boyd.ghg_emissions_by_county_and_population
ORDER BY
    ghg_normalized_by_area DESC
</code></pre>

<p>Your output table should look similar to the following screen capture:</p>

<p><img src="module-09-graphics/2016/ordered-by-normalized-data.png" alt="Emissions ordered by normalized data" /> <br/>
Figure 28: Emissions ordered by normalized data</p>

<p>Let's continue with making our web map of GHG emissions at different zoom levels.</p>

<p><a name="creating-a-multiscale-web-map-with-different-thematic-data-types"></a></p>

<h1>Creating a multiscale web map with different thematic data types</h1>

<p>Let's create a new map from this dataset. Click <strong>CREATE MAP</strong> in the lower right-hand corner. CARTO will switch to <strong>Map View</strong> where you can change your <strong>Basemap</strong> and add different layers.</p>

<p>Let's reflect on our options for our design solution. We want to show different visualizations of data at different scales. When we're zoomed out we want to aggregate our GHG emissions by US states. Zoom in a little and we can inspect our emissions by county. When we're zoomed in we want to see the individual facilities symbolized by the quantity of emissions. Of course, along the way we want to interrogate our data with useful <strong>POP-UPS</strong>.</p>

<p>So, we need the following layers on/off at varies zoom levels.</p>

<ul>
<li>Zoom levels 1-5: GHG emissions points aggregated by US states (layer "ghg_emissions_by_coal_facility")</li>
<li>Zoom levels 6-8: GHG emissions points aggregated by US counties (layer "ghg_emissions_by_county_and_population")</li>
<li>Zoom levels >8: Facilities with graduated symbols showing quantity of emissions (layer "ghg_emissions_by_coal_facility")</li>
</ul>


<p>In <strong>Map View</strong> click the <strong>ADD</strong> button to add the distinct GHG emitters you created with SQL at the beginning of the module. Find the layer in the <strong>Add new layer</strong> dialog:</p>

<p><img src="module-09-graphics/2016/layers-use-on-final-map.png" alt="The layer with one record per facility and five years of GHG emissions" /> <br/>
Figure 29: Add layer with one record per facility and five years of GHG emissions</p>

<p>Add this layer twice, since we're going to symbolize it in two different ways. Also, add some metadata to help manage your layers. Your map should look like the below screen capture:</p>

<p><img src="module-09-graphics/2016/three-layered-map.png" alt="Three layers used for symbology in the GHG emissions by coal fuel, 2011 - 2015 map" /> <br/>
Figure 30: Three layers used for symbology in the "GHG emissions by coal fuel, 2011 - 2015" map</p>

<p>Let's start with the first layer, "Emissions by facility, 2011-2015" and make a graduated symbol based on "right_total_ghg" field. Click on the layer name, then access the <strong>STYLE</strong> panel and toggle on the CartoCSS tray. We've already created some CartoCSS rules for this layer in another map. Let's take a look at the rules:</p>

<pre><code>#layer {
  marker-width: ramp([right_total_ghg], 7,60,'jenks');
   marker-fill:#FFB927;
  marker-fill-opacity: 0.4;
  marker-allow-overlap: true;
  marker-line-width: 1;
  marker-line-color: #FFF;
  marker-line-opacity: 1;
}
</code></pre>

<p>Hit <strong>APPLY</strong> and you should see the following:</p>

<p><img src="module-09-graphics/2016/point-layer-symbolized.png" alt="Point layer symbolized with graduated symbol" /> <br/>
Figure 31: Point layer symbolized with graduated symbol</p>

<p>Next, click on the "Emissions by state, 2011-2015" layer to aggregate by state using the SUM("right_total_ghg") field operation in the <strong>STYLE</strong> panel. It is helpful to turn off the visibility of other layers to help style your map.</p>

<p>The <strong>LEGEND</strong> values are a little wonky at this point. The relative comparison is the most valuable use of this visualization method. We might change these values at the end to help with interpretation. Your setting should look like:</p>

<p><img src="module-09-graphics/2016/emissions-by-state.png" alt="Emissions aggregated by state" /> <br/>
Figure 32: Emissions aggregated by state</p>

<p>Finally, let's symbolize "Emissions by county, 2011-2015" polygons using the <strong>FILL</strong> method <strong>BY VALUE</strong> using the "ghg_normalized_by_area" field. Style your map to look like the following:</p>

<p><img src="module-09-graphics/2016/emissions-by-county.png" alt="Emissions aggregated by county" /> <br/>
Figure 33: Emissions aggregated by county</p>

<p>Don't worry about <strong>LEGEND</strong> values. Just get the polygon layers in a similar color scheme. Now, apply our zoom levels.</p>

<p><a name="controlling-zoom-level-visibility-with-cartocss"></a></p>

<h2>Controlling zoom level visibility with CartoCSS</h2>

<p>For each layer's <strong>STYLE</strong> toggle to the <strong>CartoCSS</strong> tray and apply a <code>[zoom ]</code> condition as we outline before:</p>

<ul>
<li>Zoom levels 1-5: GHG emissions points aggregated by US states (layer "ghg_emissions_by_coal_facility")</li>
<li>Zoom levels 6-8: GHG emissions points aggregated by US counties (layer "ghg_emissions_by_county_and_population")</li>
<li>Zoom levels >8: Facilities with graduated symbols showing quantity of emissions (layer "ghg_emissions_by_coal_facility")</li>
</ul>


<p>For the "Emissions by state, 2011-2015" CartoCSS rules:</p>

<pre><code>/* Layer remains styled until zoom level 6 is reach */

#layer [zoom &lt; 6] {
  polygon-fill: ramp([agg_value_density], (#f9ddda, #eda8bd, #ce78b3, #9955a8, #573b88), quantiles);
  line-width: 1;
  line-color: #FFF;
  line-opacity: 1;
}
</code></pre>

<p>For the Emissions by county, 2011-2015" the CartoCSS rules are a little more elaborate. Since the style cascades down the zoom levels, we need to change the properties after zoom level is reached:</p>

<pre><code>/* Layer turn on after zoom level 6 is reach */

#layer [zoom &gt;5] {
  polygon-fill: ramp([ghg_normalized_by_area], (#f9ddda, #eda8bd, #ce78b3, #9955a8, #573b88), quantiles);
  line-width: 0.5;
  line-color: #FFF;
  line-opacity: 0.5;
}

/* Layer changes after zoom level 9 is reached */
#layer [zoom &gt;8] {
  polygon-fill: ramp([ghg_normalized_by_area], (#f9ddda, #eda8bd, #ce78b3, #9955a8, #573b88), quantiles);

  /*the polygon gets mostly transparent */
  polygon-opacity: 0.2;
  line-width: 0.5;
  line-color: #FFF;
  line-opacity: 0.2;
}
</code></pre>

<p>Finally, style the "Emissions by facility, 2011-2015" layer by adding a zoom level condition in its CartoCSS rules:</p>

<pre><code>#layer [zoom &gt; 8] {
  marker-width: ramp([right_total_ghg], 7,60,'jenks');
   marker-fill:#FFB927;
  marker-fill-opacity: 0.6;
  marker-allow-overlap: true;
  marker-line-width: 1;
  marker-line-color: #FFF;
  marker-line-opacity: 1;
}
</code></pre>

<p><a name="finishing-up-the-web-map"></a></p>

<h2>Finishing up the web map</h2>

<p>From here we have various options for improving the appearance of and experience using the map. We could add state outlines to make the map easier to read or change the basemap. We should address the <strong>LEGENDS</strong>  as well as add some <strong>POP-UP</strong> functionality for the user to derive specific values from features, either from the facilities or the counties, or both.</p>

<p>For the <strong>LEGEND</strong> try to change labels to make them more generalized. Since we're adding interactivity, users can find exact values by clicking on a feature:</p>

<p><img src="module-09-graphics/2016/example-legend.png" alt="Example legend" /> <br/>
Figure 34: Example legend</p>

<p>When you're finished, click on <strong>SHARE</strong> and publish the map.</p>

<p><a href="https://nmp.carto.com/u/boyd/builder/70739b00-bbc3-11e6-8c9f-0e3ff518bd15/embed">Here is an example final map</a></p>

<p>Additionally, we could consider reprojecting the map to an equal-area projection. However, the trade off doing that is that once we zoom past level 6 and lose the choropleth, a user may want the titled basemap in order to spatially locate and identify certain facilities. After we gain more advancing programming skills in MAP672 and MAP673 we could consider a script that would reproject the map at different zoom levels. But for now, we can ask ourselves if the trade-off is worth it. How important is it to conform to a cartographic principle (e.g., equal area projections for choropleth maps) at the expensive of allowing the user to locate specific facilities near their hometown?</p>

<!-- Highlight syntax for Mou.app, insert at the bottom of the markdown document  -->




<script src="https://yandex.st/highlightjs/7.3/highlight.min.js"></script>


<p><link rel="stylesheet" href="https://yandex.st/highlightjs/7.3/styles/github.min.css"></p>

<script>
  hljs.initHighlightingOnLoad();
</script>

</body>
</html>