<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
<title>Lesson 03: Geocoding and Point in Polygon Analysis</title>

</head>
<body>
<h1>Lesson 03: Geocoding and Point in Polygon Analysis</h1>

<hr />

<h1>Table of Contents</h1>

<!-- MarkdownTOC  autolink="true" autoanchor="true" bracket="round" depth=0 -->


<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#data-files">Data files</a></li>
<li><a href="#lesson-objective">Lesson Objective</a></li>
<li><a href="#preparing-to-geocode">Preparing to Geocode</a>

<ul>
<li><a href="#geocoding-address-data">Geocoding address data</a></li>
<li><a href="#geocoding-with-the-mmqgis-plugin">Geocoding with the MMQGIS plugin</a></li>
<li><a href="#interpreting-accuracy-of-geocoded-results">Interpreting accuracy of geocoded results</a></li>
</ul>
</li>
<li><a href="#visualizing-point-data">Visualizing point data</a></li>
<li><a href="#analysis-of-attributes-in-sql">Analysis of attributes in SQL</a>

<ul>
<li><a href="#spatial-analysis-workflow-and-ground-rules-with-db-manager--qgis">Spatial analysis workflow and ground rules with DB Manager &amp; QGIS</a></li>
<li><a href="#example-sql-statements-for-this-lesson">Example SQL statements for this lesson</a></li>
<li><a href="#analysis-queries">Analysis queries</a></li>
</ul>
</li>
<li><a href="#spatial-join">Spatial Join</a>

<ul>
<li><a href="#join-attributes-by-location-tool-spatial-join">Join attributes by location tool (spatial join)</a></li>
<li><a href="#spatial-join-in-sql">Spatial Join in SQL</a>

<ul>
<li><a href="#postgis-sql">PostGIS SQL</a></li>
<li><a href="#spatialite-sql">SpatiaLite SQL</a></li>
<li><a href="#inserting-spatial-join-output-to-a-new-table">Inserting spatial join output to a new table</a></li>
</ul>
</li>
<li><a href="#errors">Errors?</a></li>
<li><a href="#copy-final-output">Copy final output</a></li>
</ul>
</li>
<li><a href="#symbolizing-our-final-map">Symbolizing our final map</a></li>
<li><a href="#addendum-using-sql-to-create-tables">Addendum: Using SQL to create tables</a></li>
<li><a href="#resources-and-references">Resources and references</a></li>
</ul>


<!-- /MarkdownTOC -->


<p><a name="overview"></a></p>

<h1>Overview</h1>

<ul>
<li>Understand and perform geocoding of tabular data</li>
<li>Learn about some of the geocoding tools available online</li>
<li>Perform a spatial join, also know as a point in polygon analysis</li>
<li>Explore unique visualization methods in QGIS</li>
<li>Use QGIS plugin repository to extend functionality</li>
</ul>


<p><a name="data-files"></a></p>

<h1>Data files</h1>

<ul>
<li><em>fatal_encounters_victims-160718.zip</em> contains a .csv and .csvt for law enforcement related deaths in the US, 2000 - 2016. The data is derived from crowdsourced reports and compiled by the non-profit <a href="http://www.fatalencounters.org/">Fatal Encounters</a>.</li>
<li>The data you built in Lab 02, which should contain layers for US county and state polygons with attributes for population estimates.</li>
</ul>


<p><a name="lesson-objective"></a></p>

<h1>Lesson Objective</h1>

<p>In this lesson, we're going to create a county-level choropleth map of law enforcement related deaths using publicly available data from the US Census and <a href="http://www.fatalencounters.org/">Fatal Encounters</a>.</p>

<p>The available CSV data has no coordinates that we could use to map these incidents, but it does have an address attributes that we could use to locate their position. The process of adding coordinates to records using attributes is called geocoding. We'll do geocoding using a popular plugin, <strong>MMQGIS</strong>.</p>

<p>After we have a point layer of incidents, we will count the number per county. From this measure, we can easily divide by population to derive a rate incidents per population. In our bigger cities, we would expect more incidents, but which city has the highest rate per population? This analysis is called by a few names, e.g., "point in polygon" analysis, "spatial join," and just simply "intersect." We'll do this analysis with SQL in a spatial database and also show the tool that QGIS offers to complete similar analysis.</p>

<p><a name="preparing-to-geocode"></a></p>

<h1>Preparing to Geocode</h1>

<p>Inspect the <em>fatal_encounters_victims-160718.zip</em> file, which contains a .csv file, the tabular data, and a .csvt, a file that defines the data type of each column. The plugin we're using for geocoding only accepts the .csv file for input.</p>

<p>Let's add the .csv to QGIS by selecting from the QGIS's main menu <strong>Layer > Add Layer > Add Delimited Text Layer...</strong> As we pursue this course of adding/modifying/exporting data in QGIS, compare the procedure to what we have done with SQL. First, notice that there's no geometry in this file, it is only delimited text. Here is is a screen capture of the import dialog:</p>

<p><img src="module-03-graphics/q02-add-csv.png" alt="QGIS offers many options to clean your delimited text files on import" />  <br/>
Figure 01: QGIS offers many options to clean your delimited text files on import</p>

<p>Though this data shows specific places, it isn't mappable because it doesn't contain geometry coordinates. Geocoding takes an address and returns a coordinate point. Reverse geocoding, does the opposite, taking a coordinate point and returning an address.</p>

<p>We need first to consider the quantity of data we will be geocoding. Online geocoders limit how many addresses you request in a given period. The Google Maps API, for instance, limits users to 2,500 requests in a 24-hour period. Other geocoders will let you make unlimited requests, but limit how many you can make in one pass. The US Census's geocoder will only accept 1000 addresses in a batch, but you can run unlimited batches. To accommodate these limitations, we're going to use just 2015 records.</p>

<p>Let's use a <strong>Filter</strong> function to reduce the 9,773 records we geocode. From our past two lessons, we should recognize this feature as an SQL query builder. Right-click the layer in the <strong>Layers Panel</strong> and select <strong>Filter...</strong> Let's select only incidents reported in 2015.</p>

<p>Make the Query Builder expression like this:
<img src="module-03-graphics/q03-filter-csv.png" alt="A Query Builder Expression" /> <br/>
Figure 02: Extracting records by attribute with <strong>Query Builder</strong> and SQL</p>

<p>Open the attribute table by right-clicking the layer and selecting <strong>Open Attribute Table</strong>. Verify you only have records for 2015. The record count should be 1261 incidents. Next, right-click the layer and <strong>Save As...</strong> a new .csv file called <em>fatal_encounters_victims-12015.csv</em>. Make the CRS is NAD83 (EPSG: 4269), and the <strong>CREATE_CSVT</strong> option is set to "Yes." Your window should look like the following:</p>

<p><img src="module-03-graphics/q04-save-csv.png" alt="Save Layer As a subset of Total records" /> <br/>
Figure 03: Saving a new .csv file containing only 2015 incidents and with correct field data types</p>

<p>Now you're ready to geocode!</p>

<p><a name="geocoding-address-data"></a></p>

<h2>Geocoding address data</h2>

<p>There are two general ways that geocoders work:</p>

<ul>
<li>interpolating location along a line, such as along street segments with attribute for address block number (and an attribute telling which way the block numbers count), and by</li>
<li>using parcel data, such as by zip code.</li>
</ul>


<p>There are lots of geocoding tools available online and each has their unique advantages and limitations. Geocoding is big business, and the best geocoders cost money to use, unfortunately.</p>

<p>Some of the common tools are:</p>

<ul>
<li><a href="https://geocoding.geo.census.gov/">Geocoder from the US Census</a></li>
<li>Google Maps (available through their API and MMQGIS)</li>
<li>OpenStreetMap Nomative (through their API and MMQGIS)</li>
<li><a href="http://www.address.io">address.io</a></li>
<li><a href="http://www.gpsvisualizer.com/geocoder/">GPSVisualizer</a></li>
</ul>


<p>To get a better idea of the differences, we're going to geocode our 2015 data using two different geocoders.</p>

<p><a name="geocoding-with-the-mmqgis-plugin"></a></p>

<h2>Geocoding with the MMQGIS plugin</h2>

<p>Let's get our first plugin for QGIS! One of the remarkable features of Q is the fervor and diversity of plugin development. Many of the tools we commonly use in QGIS started out as a plugin. We're going to install the <a href="https://plugins.qgis.org/plugins/mmqgis/">MMQGIS plugin</a> via QGIS's <strong>Plugin Manager</strong>. Find it the QGIS menu <strong>Plugins > Manage and Install Plugins...</strong>* Then, search for "MMQGIS" and install it:</p>

<p><img src="module-03-graphics/q05-install-mmqgis.png" alt="Install MMQGIS plugin" />   <br/>
Figure 04: Install MMQGIS plugin</p>

<p>After a successful install, find the new tools in QGIS's main menu entry, <strong>MMQGIS</strong>. We have a couple of options for geocoding our data, we can use either the Google Maps API, OpenStreetMaps (OSM) Nominative, or if we have it, street centerline data with address block number. We're going to use the Google and OpenStreetMap options.</p>

<p>We'll use the OpenStreetMap Nomative tool first. Click on <strong>MMQGIS</strong> in the top menu bar and select <strong>Geocode</strong> from Google Maps/OpenStreetMaps. In the dialog box that opens up, browse to the 2015 dataset. Make sure that the correct fields were selected for the address, city and state fields. We didn't have a country field, so that should be blank. You'll want to add "OSM" to the end of the automatically created shapefile name so that we know that this is the output from the OSM geocoder. You'll also need to click the browse button for the not found output. Name the file "notfound_2015_OSM.csv" and tell QGIS where to save that file. Finally, click <strong>OK</strong>.</p>

<p><img src="module-03-graphics/q06-geocode-mmqgis.png" alt="MMQGIS Plugin setting" />   <br/>
Figure 05: Geocode settings</p>

<p>Now, we wait. No, really. Make yourself a cup of coffee, maybe brush up on a foreign language. Geocoding can be a slow process. This is going to take some time. QGIS might look like it has frozen in time, but it should be creating a new Shapefile (the only output format for this tool). Inspect the folder you saved the Shapefile. If you notice the .dbf file size increasing, QGIS is crunching away!</p>

<p>Once the tool finishes, you'll see a slew of tiny dots all across the US and if you check your file manager, you'll see you've got a new Shapefile and a new CSV file. The Shapefile contains the point data for all the addresses that the geocoder found, while the CSV is a list of addresses it did not.</p>

<p>Now repeat the process using the Google Map geocoder. Add "GM" to the end of the shapefile and the not found file names, so you'll be able to identify them later. The Google Maps API maxes out at 5 seconds per address request, and you've just asked it to geocode a whole bunch of them. So, maybe some more coffee?</p>

<p><strong>TIP!</strong> Please note that if you're using the Google geocoder you have a daily limit per IP address. If you want to continue to use Google geocoder, try a different computer (on a different network) or work in small batches while you experiment in the beginning.</p>

<p><a name="interpreting-accuracy-of-geocoded-results"></a></p>

<h2>Interpreting accuracy of geocoded results</h2>

<p>Why didn't it match all of them?</p>

<p>The Google tool results:
<img src="module-03-graphics/_GoogleGeoCode.png" alt="Image of geocoded addresses from Google Geocoder" /> <br/>
Figure 06: Image of sample geocoded addresses from Google geocoder shows 1239 out 1261 matches, 98%.</p>

<p>Now the OSM tool results:
<img src="module-03-graphics/_OSMGeoCode.png" alt="Image of geocoded addresses from GOSM Geocoder" /> <br/>
Figure 07: Image of sample geocoded addresses from OSM geocoder shows 512 out 1261 matches, 41%.</p>

<p>It is pretty clear that we got different results from the two geocoders. Google Maps returned a lot more results than OpenStreetMap. Why is that?</p>

<p>The accuracy of your geocoding results depend on the quality of the locator dataset it's using for interpolation. OpenStreetMap is a crowdsourced map with has holes in its coverage because there are some places that nobody in the crowd has decided to spend a lot of time mapping yet. However, OpenStreetMap's data improves and expands on a daily basis, and depending on the specific location that you're mapping, you may get better or worse results. Even though OSM didn't return as many results as Google Maps, there are reasons to use OSM over Google Maps. OSM doesn't have the 2,500 addresses per 24-hour period limit that Google Maps has, and its data is under a Creative Commons license which means you have more rights related to its use than that of Google Maps.</p>

<p>Inspect the attributes; you'll notice that there are two new fields, <em>addrtype</em> and <em>addrlocat</em>. These columns give you an idea of the accuracy of the geocoder's results.</p>

<p>If we look at our notfound files, we can get an idea of what kind of addresses trip up the geocoders.  The <em>notfound</em> file is your opportunity to search for mistakes in the original record, correct them and potentially run them through the geocoder again.</p>

<p>Make another .csv address tables, perhaps of your favorite taco bars and cupcake bakeries. Compare the results of areas you know and decide which geocode tool fits your needs.</p>

<p><a name="visualizing-point-data"></a></p>

<h1>Visualizing point data</h1>

<p>OK, let's visualize our data. Add your layers into a new QGIS document and project your Map Canvas to EPSG: 102008:</p>

<p><img src="module-03-graphics/q08-qgis-map-canvas.png" alt="Visualizing our geocoded data" /> <br/>
Figure 08: Visualizing our geocoded data</p>

<p>It becomes apparent that making sense of 1239 points on a map is an iterative process. We will discover some analysis techniques in the following sections that aggregate these points by different units of geography, e.g. county polygons. For now, let's investigate some methods for symbolizing features available in QGIS.</p>

<p>Let's use QGIS's <a href="https://docs.qgis.org/2.14/en/docs/user_manual/working_with_vector/vector_properties.html#layer-rendering"><strong>Layering rendering</strong></a> techniques to build up symbol density. These visual effects are unique among GIS mapping apps and more similar to graphic design apps like Photoshop. <a href="https://docs.qgis.org/2.14/en/docs/user_manual/introduction/general_tools.html#blend-modes"><strong>Blending modes</strong></a> determine how overlapping layers and features mix. The default <strong>Normal</strong> mode with 0% transparency; the layer and feature are entirely opaque. We can independently modify the transparency of the outline and fill of a symbol object.</p>

<p>We can change the blending mode for an entire layer and individual features in a layer.  Let's change the <strong>Feature blending mode</strong> to <strong>Addition</strong>, the effect of which QGIS defines as, "This blend mode simply adds pixel values of one item with the other. In case of values above one (in the case of RGB), white is displayed. This mode is suitable for highlighting features." Experiment with various combinations and see how we can locate areas with a high density of points.</p>

<p><img src="module-03-graphics/q09-blending-mode.png" alt="Feature blending modes to highlight symbol density" /> <br/>
Figure 109: Feature blending modes to highlight symbol density</p>

<p>Continue experimenting with different blending modes and transparency settings. Take note of how feature blending modes differ from layer blending modes. Play with changing a symbol's fill and line opacity. The goal is to develop a <a href="http://www.geog.nau.edu/courses/rh83/pl431/workbook/mapdesign.pdf">visual hierarchy</a> in your map's presentation; the map's topic is the most important visual element while supporting layers fade into the background. Consult the UK's Ordinance Survey about the <a href="https://www.ordnancesurvey.co.uk/resources/carto-design/carto-design-principles.html">10 principles of cartographic design</a>.</p>

<p><a name="analysis-of-attributes-in-sql"></a></p>

<h1>Analysis of attributes in SQL</h1>

<p>To start with let's create a new spatial database. From your Lab 02, use DB Manager to export/import layers for this project, especially in regards to making your table join permanent. Consult the last section in Lesson 02 for a refresher.</p>

<p>After you have your project space setup, you should have the following in your database, i.e., note the attributes for the county polygon table:</p>

<p><img src="module-03-graphics/q01-create-db.png" alt="Create a spatial database for this lesson" />  <br/>
Figure 10: Set up your database with the layers needed in this analysis</p>

<p>In our previous lessons, we've been creating layers 'on the fly' with SQL queries. The idea is that we keep a master spatial database that we select out features and attributes and create symbology as need them. This gives us the opportunity to make unlimited maps while not duplicating data nor gobbling up more disk space.</p>

<p>At some point, we might find that our queries slow redraw time for layers in Map Canvas. When our SQL becomes too complex, too expensive to use efficiently, we can <strong>render</strong> our views or virtual layers to new tables. We will create new data requiring more disk storage space, but it will be much more responsive in QGIS.</p>

<p>Let's suggest some guidance and help you perform analysis with a minimal headache.</p>

<p><a name="spatial-analysis-workflow-and-ground-rules-with-db-manager--qgis"></a></p>

<h2>Spatial analysis workflow and ground rules with DB Manager &amp; QGIS</h2>

<p>The general workflow for spatial analysis in a database is to:</p>

<ol>
<li>Create and execute an SQL query that analyzes a subset of our data.</li>
<li>Load that query as a new layer in Map Canvas.</li>
<li>If the attributes and geometry look reasonable, insert the full output of a query into a new table.</li>
<li>Copy that new table into a different database to share your analysis.</li>
<li>Keep a scratch database or schema where you can store temporary tables or render queries</li>
</ol>


<p>As we create new layers, let's observe some data hygiene rules:</p>

<ul>
<li>All layers must share the same coordinate system. If you are creating geometry measures (calculating area, etc.), the layers must use the same projected coordinate system.

<ul>
<li>Maintain a master database with all layers in the same coordinate system.</li>
<li>Create a second spatial database that contains rendered data, a subset or combination of master database layers.</li>
</ul>
</li>
<li>To avoid conflicts with other tools down the workflow let's keep a consistent naming scheme for our layers, tables, views, and column names.

<ul>
<li>Use only underscores, lowercase letters, and numbers.</li>
<li>Substitute spaces with underscores.</li>
<li>Don't start names with numbers.</li>
</ul>
</li>
</ul>


<p>OK, let's add the best-geocoded dataset to our database with two modifications from our previous imports into SpatiaLite: make the <strong>Target SRID</strong> "4269", which is the NAD83, and format our table name as we just outlined.</p>

<p><img src="module-03-graphics/q07-import-geocoded-data.png" alt="Import and project layer on import to spatial database" /> <br/>
Figure 11: Import and project layer on import to spatial database</p>

<p><a name="example-sql-statements-for-this-lesson"></a></p>

<h2>Example SQL statements for this lesson</h2>

<p>Before we start executing SQL, let's find example statements we can use during the lesson. If you haven't changed table names, you should be able to copy these statements and paste them into DB Manager.</p>

<ul>
<li><a href="https://gist.github.com/boydx/0ff3635cac27b6f7d7bd633030b46deb">PostGIS</a></li>
<li><a href="https://gist.github.com/boydx/02e2a3548187226dd8121b6c7327999f">SpatiaLite</a></li>
</ul>


<p><a name="analysis-queries"></a></p>

<h2>Analysis queries</h2>

<p>We already have a lot attributes that we can analyze in our data before we geocoded it. We can answer questions like, "which state, city, or zip code have the most?" Depending on the attributes available, we can use SQL <code>group by</code> statement  and <code>count()</code> function to aggregate and count records by an attribute value.</p>

<p>Let's access our records:</p>

<pre><code>/* Get all columns and records */

select
    *
from 
    fatal_encounters_victims_2015
</code></pre>

<p>Now we want to count the number of non-NULL records in the fields <em>st</em> and <em>id</em>:</p>

<pre><code>/* Count records that are not NULL */

select 
    st, count(st) as count_of_states_not_null, count(id)
from 
    fatal_encounters_victims_2015
</code></pre>

<p>It looks like we have one record without a state value. The <em>id</em> field is the unique identifier that is given to every record by default and is never null.</p>

<p>Add the <code>group by</code> statement and choose the field you wish to aggregate. For example, the following the statement can be interpreted as, for each unique occurrence in <em>st</em>, count the number of records that are not null. In other GIS apps, this statement is similar to a "dissolve" or "summary statistics." The following SQL counts the number of incidents in each state:</p>

<pre><code>/* Count incidents in each state and rank them high to low */

select 
    st, count(st) as count
from 
    fatal_encounters_victims_2015
group by
    st
order by
    count desc
</code></pre>

<p>You should have a similar output as below:</p>

<p><img src="module-03-graphics/q11-output-table-analysis.png" alt="Counting incidents by state" /> <br/>
Figure 12: Counting incidents by state</p>

<p>Any field that has a class value can be aggregated and counted. The gender breakdown of incidents:</p>

<pre><code>/* Count by gender */

select 
    gender, count(gender) as count
from 
    fatal_encounters_victims_2015
group by 
    gender
order by
    count desc
</code></pre>

<p>We can add columns that compare counts to total (non-null records we derived earlier) by adding calculated measures:</p>

<pre><code>
/* Count incidents by ethnicity and calculate percent of total */

select 
    ethnicity, count(ethnicity) as count, round((count(ethnicity)/1238.0),4)*100 as percent_total
from 
    fatal_encounters_victims_2015
group by
    ethnicity
order by
    count desc
</code></pre>

<p>If we have numeric fields, we can add statistical functions to out output columns. We have a field for the age of the victim. Let's find the average age with the <code>avg()</code> function:</p>

<pre><code>/* Average age of victim */

select 
    count(age) as count, avg(age)
from 
    fatal_encounters_victims_2015
</code></pre>

<p>As you can see in the count, we have a few more null fields than in other fields. Now, let's add the <code>min()</code> and <code>max()</code> functions. Be aware of the alphanumeric fields with only numbers, because some of these functions can work text strings.  Execute this statement and examine its output:</p>

<pre><code>/* Average age of victim and min/max? */

select 
    count(age) as count, avg(age), min(age), max(age)
from 
    fatal_encounters_victims_2015
</code></pre>

<p>This gives inaccurate results because the fields have been converted to text by the geocoding tool. We can add the <code>cast()</code> function to cast our text fields to numeric:</p>

<pre><code>/* Find min, max, and average age  */

select 
    count(age) as count, 
    avg(age) as average_age, 
    min(cast(age as real)) as minimim_age,
    max(cast(age as real)) as maximum_age
from 
    fatal_encounters_victims_2015
</code></pre>

<p>Let's finish by showing the possibility for more detailed analysis by grouping multiple attributes with statistical functions and then render the query off to our new database:</p>

<pre><code>/* Group incidents by state and gender */

select 
    gender, st as state,
    count(gender) as count, 
    round(avg(age),1) as average_age
from 
    fatal_encounters_victims_2015
group by 
    gender, st
order by
    st
</code></pre>

<p>The output will give us the average age of victims by state and gender, e.g., California had 21 female victims with an average age of 34.1, while the same state had 212 male victims and was on average slightly older at 34.3.</p>

<p>Now <strong>Create a view</strong> and use the naming convention discussed earlier. A view is a stored query.  To render the query to a new table and database, either <strong>Export</strong> the view or click+drag the view from the source database to the render database:</p>

<p><img src="module-03-graphics/q12-output-table-analysis.png" alt="Moving a table view to a new database" /> <br/>
Figure 13: Moving a table view to a new database</p>

<p>It is apparent that heavily populated states have more incidents. We should normalize the incidents by total population. As shown in the last lesson, we could do an attribute join with a table that has the population as an attribute. We could join by state or zip code because we have those uniquely identified in our table.</p>

<p>However, what if we wanted to count these incidents by county or city? Let's explore a method that analyzing locations by spatial proximity to another layer.</p>

<p><a name="spatial-join"></a></p>

<h1>Spatial Join</h1>

<p>In the last lesson, we joined attributes from different tables based on a field of shared values. In this section, we'll join attributes from different layers based on shared locations of their features. We'll do a "point in polygon" or "many to one" spatial join that will count the number points from one layer that are within polygons of another layer.</p>

<p>This analysis is easy to imagine for our lesson; we have locations of incidents and we want to count the number in each county polygon. We might also want to find the average age of the victim. Since our attribute table doesn't offer information about which county the incident occurred (just state and zip code), we have to use the spatial join to analyze patterns at smaller units of geography.</p>

<p><a name="join-attributes-by-location-tool-spatial-join"></a></p>

<h2>Join attributes by location tool (spatial join)</h2>

<p>QGIS has wrapped this type of analysis into a nice tool. We won't have the same type of control over attributes, but it does run a little faster. First, make sure you have the point and polygon layers in your <strong>Layers Panel</strong>. QGIS tools use these layers for selecting input. Find the tool in <strong>QGIS menu > Vector > Data Management Tools > Join attributes by location</strong>.</p>

<p>The tool settings are almost identical to our spatial join SQL query. The main difference is that we can't select the attributes we want in the output and need to select <strong>Take summary of intersection features</strong> in the <strong>Attribute summary</strong> parameter. This allows for the "many-to-one" type spatial join. The tool settings should be:</p>

<p><img src="module-03-graphics/q17-join-attributes-tool.png" alt="Join attributes by location tool" />  <br/>
Figure 14: Join attributes by location tool</p>

<p>Let's discuss some considerations using this tool. If the join is doing summary statistics, the numeric fields cannot have NULL values. Since the geocoder made all attributes as TEXT data type, this tool also won't change data types "on the fly". So, as always, we need to be aware of our attributes before using this tool and convert them if necessary.</p>

<p>Depending on the format to which we output, we could change our column names.  If you don't specify a name in the <strong>Joined layer</strong> output (leaving "Create temporary layer") you shouldn't have any field name changes. That's the preferred method.</p>

<p>If you add a name for the output, it defaults to Shapefile format and truncates our long column names. If you select to save output as a <strong>SpatiaLite table...</strong>, you'll need to select the database and add the name in the <code>table="my_table_name"</code> text:</p>

<p><img src="module-03-graphics/q18-join-attributes-tool.png" alt="Join attributes by location tool" />  <br/>
Figure 15: Join attributes by location tool</p>

<p>As you can see, the tool provides convenience but lacks many of the options we find in our SQL method. I would encourage focusing on SQL more than the QGIS tools. Eventually, we will be in CARTO, which uses PostGIS. Get in the habit of saving successful SQL queries as text files and reusing on different databases and datasets.</p>

<p><a name="spatial-join-in-sql"></a></p>

<h2>Spatial Join in SQL</h2>

<p>Spatial joins in QGIS, SpatiaLite, and PostGIS use the GEOS library to determine spatial proximity between features. The various ways to determine spatial proximity, i.e., if two features overlap, are listed in SpatiaLite's <a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-4.3.0.html#p12">documentation</a>. One of the more common functions to test for spatial relationships (often called <em>geometric predicates</em>) is <code>st_intersects()</code> and is defined, "if a geometry or geography shares any portion of space then they intersect. For geography -- tolerance is 0.00001 meters (so any points that are close are considered to intersect)." We'll continue to aggregate and summarize attributes using the <code>group by</code> statement.</p>

<p><a name="postgis-sql"></a></p>

<h3>PostGIS SQL</h3>

<p>There is a difference this week between PostGIS and SpatiaLite. The <code>group by</code> statement in PostGIS is more restrictive than in SpatiaLite, but PostGIS is more efficient. The steps are covered in the <a href="https://gist.github.com/boydx/0ff3635cac27b6f7d7bd633030b46deb">PostGIS SQL</a> example starting at line 139.</p>

<p><a name="spatialite-sql"></a></p>

<h3>SpatiaLite SQL</h3>

<p>Let's create our first spatial join query:</p>

<pre><code>/* Spatial join to count incidents by county */

select
    county_population_estimates_2015.name,
    county_population_estimates_2015.POP_ESTIMATE_2015,
    count(fatal_encounters_victims_2015.id) as count
from
    /* Target layer with enumeration units */
    county_population_estimates_2015
join
    /* Source layer that will be counted/analyzed */
    fatal_encounters_victims_2015
on
    /* Geometric predicate intersect */
    st_intersects(county_population_estimates_2015.geom,fatal_encounters_victims_2015.geom) 
where
    /* Use where clause to subset for Kentucky. First two digits in geoid indicate state.  */
    county_population_estimates_2015.geoid like '21%'
group by
    /* Aggregate attribute */
    county_population_estimates_2015.geoid
order by
    count desc
</code></pre>

<p>Kentucky has 120 counties, but only 15 are returned with this query. Like the attribute join, the default join is an <code>inner join</code> where the output table contains only matching records. If we want all counties in the output table, regardless if they have incidents or not, we need to use the <code>left outer join</code>:</p>

<pre><code>/* Spatial join to count occurrences by county */

select
    county_population_estimates_2015.name,
    county_population_estimates_2015.POP_ESTIMATE_2015,
    count(fatal_encounters_victims_2015.id) as count
from
    /* Target layer with enumeration units, the left table*/
    county_population_estimates_2015
left outer join     
    /* Source layer that will be counted/analyzed, the right table */
    fatal_encounters_victims_2015
on
    /* Geometric predicate intersect */            st_intersects(county_population_estimates_2015.geom,fatal_encounters_victims_2015.geom) 
where
    /* Use where clause to subset for Kentucky. First two digits in geoid indicate state.  */
    county_population_estimates_2015.geoid like '21%'
group by
    /* Aggregate attribute */
    county_population_estimates_2015.geoid
order by
    count desc
</code></pre>

<p>Now let's add some statistics to our output table. We have the age of the victim for each incident so that we can find the average age for each county. We can also add a column to normalize our raw count of incidents:</p>

<pre><code>/* Spatial join to count incidents by county */

select
    county_population_estimates_2015.name,
    county_population_estimates_2015.POP_ESTIMATE_2015,
    count(fatal_encounters_victims_2015.id) as count,
    /* Find average age. Since attribute is text, use cast() function to make a real numeric data type. Note that the field name 'age' is unique between tables and don't need to preface with table name.*/
    round(avg(cast(age as real)),1) as avg_age,
    /* Normalize by county population */
    round((count(cast(age as real))/county_population_estimates_2015.POP_ESTIMATE_2015*10000),2) as rate_per_10000

from
    /* Target layer with enumeration units */
    county_population_estimates_2015
join
    /* Source layer that will be counted/analyzed */
    fatal_encounters_victims_2015
on
    /* Geometric predicate intersect */
    st_intersects(county_population_estimates_2015.geom,fatal_encounters_victims_2015.geom) 
where
    /* Use where clause to subset for Kentucky. First two digits in geoid indicate state.  */
    county_population_estimates_2015.geoid like '21%'
group by
    /* Aggregate attribute */
    county_population_estimates_2015.geoid
order by
    count desc
</code></pre>

<p>Your output should look like the following:</p>

<p><img src="module-03-graphics/q13-output-table-spatial-join.png" alt="Output for spatial join query" />  <br/>
Figure 16: Output for spatial join query</p>

<p><a name="inserting-spatial-join-output-to-a-new-table"></a></p>

<h3>Inserting spatial join output to a new table</h3>

<p>When you work with complex spatial queries, like this join, you'll soon discover that they require a lot of time to redraw. When you have a good statement, you can create a table from the statement's output. If you are working in a PostGIS database, we use a little different approach with the <code>create table</code> statement. You find those steps in the <a href="https://gist.github.com/boydx/0ff3635cac27b6f7d7bd633030b46deb">PostGIS SQL document</a> starting at line 139.</p>

<p>The following method works in both types of databases. We'll need to render our query to a new table for more efficient use using the SQL <code>insert into</code> statement.</p>

<p>First,  create a new table via the <strong>DB Manager menu > Table > Create Table</strong> dialog. In the resulting dialog give field names, data types, an <em>id</em> field, and the correct geometry type and EPSG: 4269. Make sure you make fields nullable in case you get null outputs, which could cause the SQL <code>insert</code> statement to fail.</p>

<p><img src="module-03-graphics/q14-create-table.png" alt="Create Table to receive spatial join output" />  <br/>
Figure 17: Create Table to receive spatial join output</p>

<p>After creating the table, open the table's <strong>Info</strong> tab (you might need to reconnect) and copy the field names in the order presented. The <code>insert into</code> statement uses the order of field names for adding data:</p>

<p><img src="module-03-graphics/q15-table-types.png" alt="Table column names and datatypes " />  <br/>
Figure 18: Table column names and datatypes</p>

<p>Let's build the first part of our query. We need to start with the <code>insert</code> statement and add the list fields:</p>

<pre><code>insert into
    incidents_by_county
(
name,
pop_2015_est,
count,
avg_age,
rate_per_10000,
geom 
)
</code></pre>

<p>The SQL that follows is pretty much the same as we have executed in the last step with one important distinction. The order of the <code>select</code> columns must match the order of the field names listed after the <code>insert</code> statement. The <em>id</em> column is skipped since it is autogenerated during the insert. Also, let's do an inner join and remove the <code>where</code> clause to finish our statement:</p>

<pre><code>/* Spatial join to count incidents by county */

Insert into incidents_by_county

(name,
pop_2015_est,
count,
avg_age,
rate_per_10000,
geom)


select
    county_population_estimates_2015.name as name,
    county_population_estimates_2015.POP_ESTIMATE_2015 as pop_2015_est,
    count(fatal_encounters_victims_2015.id) as count,
    /* Find average age. Since attribute is text, use cast() function to make a real numeric data type. Note that the field name 'age' is unique between tables and don't need to preface with table name.*/
    round(avg(cast(age as real)),1) as avg_age,
    /* Normalize by county population */
    round((count(cast(age as real))/county_population_estimates_2015.POP_ESTIMATE_2015*10000),2) as rate_per_10000,
    county_population_estimates_2015.geom as geom

from
    /* Target layer with enumeration units */
    county_population_estimates_2015
join
    /* Source layer that will be counted/analyzed */
    fatal_encounters_victims_2015
on
    /* Geometric predicate intersect */
    st_intersects(county_population_estimates_2015.geom,fatal_encounters_victims_2015.geom) 
group by
    /* Aggregate attribute */
    county_population_estimates_2015.geoid
order by
    count desc
</code></pre>

<p>After you <strong>Execute</strong> the query, it might take awhile to complete. That's one reason we did the inner join to help limit the number of records processed. It will also help with classification and symbology. Inspect your output and should see the following table:</p>

<p><img src="module-03-graphics/q16-join-output.png" alt="Table output from spatial join" />  <br/>
Figure 19: Table output from spatial join</p>

<p><a name="errors"></a></p>

<h2>Errors?</h2>

<p>As you might discover, both you and QGIS will make mistakes. If you need to delete records from a table because an <code>insert</code> or <code>create table</code>  didn't of go as expected, then use the following:</p>

<pre><code>/* Delete all records from a table */

delete from incidents_by_county
</code></pre>

<p>If you get output that doesn't make sense, you might need to restart DB Manager or even QGIS. I have noticed that the <code>group by</code> functions sometimes don't work after an <code>insert</code> fails. Restarting QGIS fixes the issue. These errors seem more of a SpatiaLite/QGIS connection. In the more robust PostGIS platform, these SQL statements run much better.</p>

<p><a name="copy-final-output"></a></p>

<h2>Copy final output</h2>

<p>To finish our analysis, we want to add the newly joined data to our render database or new schema, which holds only our unique analysis output. While this isn't always necessary, it's a good practice for managing and sharing data you've created. In your DB Manager, drag the successful output to your new database or schema. You'll be prompted with an import layer dialog:</p>

<p><img src="module-03-graphics/q19-copy-layer.png" alt="Copy tables to other databases" />  <br/>
Figure 20: Copy tables to other databases</p>

<p><a name="symbolizing-our-final-map"></a></p>

<h1>Symbolizing our final map</h1>

<p>The last thing for us to do is to symbolize our data in some thematic way. The choropleth map is a good choice for this since our data is aggregated to county polygons.</p>

<p>Let's symbolize the <em>incidents_by_county</em> layer for our final map. First, put the map in the <strong>EPSG:102008</strong> equal-area projection. Right-click on the <em>incidents_by_county</em> layer and go to <strong>Properties</strong>. Select <strong>Style</strong>, then change the symbology to <strong>"Graduated"</strong>,  choose <strong>Count</strong> as the Column, set the Mode to <strong>Natural Breaks (Jenks)</strong> and then click <strong>Classify</strong>. You should now see five classes defined in the center of the dialog box. You'll need to correct the legend as you have in previous modules being sure to adjust the color and labels as needed.</p>

<p><img src="module-03-graphics/q20-map-raw-count.png" alt="Raw count symbology" /> <br/>
Figure 21: Raw count per county</p>

<p>Since we did the inner join we will not have all counties to symbolize; we have holes in our data. To visually balance the missing counties, we will need a layer underneath the <em>incidents_by_county</em>. I added a second layer of the state polygons and styled it without an outline, <strong>Style > Single Symbol > Simple fill > Outline style > No pen</strong> and labeled it, "Counties without incidents."</p>

<p>Another useful symbology technique is to remove (or diminish) outlines on our graduated county polygons, which can sometimes obscure smaller counties. After you set the graduated fill colors the way you like them, click <strong>Symbol: Change...</strong> and change the outline settings. This will change the symbols for all classes. If you change the fill color, you'll lose your graduated color scheme!</p>

<p><img src="module-03-graphics/q22-changing-all-symbols.png" alt="Changing symbol properties for all classes" />  <br/>
Figure 22: Changing symbol properties for all classes</p>

<p>Of course, we spent time making a normalized column for these incidents, so let's finally visualize the results:</p>

<p><img src="module-03-graphics/q21-map-rate-per-10000.png" alt="normalized count symbology" /> <br/>
Figure 23: Rate per 10,000 population</p>

<p>What explains the difference in these two maps? The raw count is biased towards high population counties; more people more incidents. The rate per population could identify those counties with abnormally high and low incidents. This map is also susceptible to over-representing counties with low populations, though.</p>

<p><a name="addendum-using-sql-to-create-tables"></a></p>

<h1>Addendum: Using SQL to create tables</h1>

<p>In the previous two lessons we've shown how to use DB Manager to create tables and edit new columns. It is a handy to start with an empty, since DB Manager limits your options to acceptable parameters.</p>

<p>Let's first take a look at how we created a table with DB Manager:</p>

<p><img src="module-03-graphics/q14-create-table.png" alt="Create Table to receive spatial join output" />  <br/>
Figure 24: Create Table in DB Manager</p>

<p>Notice the required fields <em>"Name"</em>, <em>"Type"</em>, and <em>"NULL"</em> (can the field contain null values?). Now, let's take a look at how we would make the same table:</p>

<pre><code>/************ Step 1 ************/

/* Create a new table without geometry column */

create table incidences_by_county   
    (
    id integer not null primary key, 
    name text null,
    pop_2015_est real null,
    count real null,
    avg_age real null,
    rate_per_10000 real null
    ) 
</code></pre>

<p>Inside the parentheses we list the columns separated by commas with following sequence of parameters: <em>"Name of column"</em>, <em>"Data type"</em>, and <em>"Is it nullable"</em>. The exception is that the <em>id</em> column contains the <code>primary key</code> parameter which makes this field the auto incrementing unique identifier for each record.</p>

<p>Our new table has no geometry. Since SpatiaLite is an extension to SQLite, we need to execute another statement to add our <em>geom</em> column using the <code>AddGeometryColumn()</code> function:</p>

<pre><code>/************ Step 2 ************/

/* Add empty geometry column */

select 
    AddGeometryColumn('incidences_by_county', 'geom', 4269, 'multipolygon', 'xy') 
    -- PostGIS: AddGeometryColumn('incidences_by_county', 'geom', 4269, 'multipolygon', 2) 
</code></pre>

<p>The sequence of parameters in the <code>AddGeometryColumn()</code> function is:
<em>"Name of table"</em>, <em>"Name of column"</em>, <em>"SRID"</em>, <em>"Geometry type"</em>, and <em>"dimensions"</em>.</p>

<p>After these two steps in SQL, you should have an identical table you made earlier in the lesson to insert the output of a spatial join.</p>

<p>However, in PostGIS we can use the <code>CREATE TABLE ... AS</code> statement that automatically creates a table from a <code>SELECT</code> statement.</p>

<p><a name="resources-and-references"></a></p>

<h1>Resources and references</h1>

<ul>
<li><a href="https://www.census.gov/cgi-bin/geo/shapefiles2014/main">US Census data</a></li>
<li><a href="http://www.fatalencounters.org/spreadsheets/">Fatal Encounters dataset</a></li>
<li><a href="http://spatial.usc.edu/wp-content/uploads/2014/03/gislabtr10.pdf">Swift JN, DW Goldberg, and JP Wilson.</a> 2008. <em>Geocoding Best Practices: Review of Eight
Commonly Used Geocoding Systems.</em> Los Angeles, CA, University of Southern California GIS</li>
<li><a href="">Research Laboratory, Technical Report No 10.</a></li>
<li>PostGIS <code>st_intersects()</code> function <a href="http://postgis.net/docs/ST_Intersects.html">documentation</a></li>
<li><a href="https://www.gaia-gis.it/gaia-sins/spatialite-sql-4.3.0.html">SpatiaLite 4.3.0 functions</a></li>
</ul>


<!-- Highlight syntax for Mou.app, insert at the bottom of the markdown document  -->




<script src="https://yandex.st/highlightjs/7.3/highlight.min.js"></script>


<p><link rel="stylesheet" href="https://yandex.st/highlightjs/7.3/styles/github.min.css"></p>

<script>
  hljs.initHighlightingOnLoad();
</script>

</body>
</html>