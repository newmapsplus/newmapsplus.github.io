<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
<title>Lesson 02: Thematic Data Mapping With Table Joins</title>

</head>
<body>
<h1>Lesson 02: Thematic Data Mapping With Table Joins</h1>

<hr />

<h1>Table of Contents</h1>

<!-- MarkdownTOC autolink="true" autoanchor="true" bracket="round" depth=0 -->


<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#data-files">Data files</a></li>
<li><a href="#natural-earth-data">Natural Earth Data</a></li>
<li><a href="#spatial-database-option">Spatial database option</a>

<ul>
<li><a href="#example-sql-statements-for-this-lesson">Example SQL statements for this lesson</a></li>
</ul>
</li>
<li><a href="#exploring-natural-earth-data-attributes">Exploring Natural Earth data attributes</a></li>
<li><a href="#using-db-manager-to-inspect-attributes">Using DB Manager to inspect attributes</a></li>
<li><a href="#thematic-map-color-schemes">Thematic map color schemes</a>

<ul>
<li><a href="#projecting-the-map">Projecting the map</a></li>
</ul>
</li>
<li><a href="#choropleth-map">Choropleth map</a>

<ul>
<li><a href="#calculating-geometry-measures">Calculating geometry measures</a>

<ul>
<li><a href="#calculating-geometry-measures-in-sql">Calculating geometry measures in SQL</a>

<ul>
<li><a href="#adding-custom-projections-to-a-spatial-database">Adding custom projections to a spatial database</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#normalizing-by-polygon-area-to-create-the-choropleth-map">Normalizing by polygon area to create the choropleth map</a></li>
<li><a href="#customizing-the-legend">Customizing the Legend</a></li>
</ul>
</li>
<li><a href="#joining-tabular-data-to-natural-earth-geometry-data">Joining tabular data to Natural Earth geometry data</a>

<ul>
<li><a href="#making-joins-permanent-for-table-edits-and-calculations">Making joins permanent for table edits and calculations</a></li>
<li><a href="#performing-the-join-in-sql">Performing the join in SQL</a></li>
</ul>
</li>
<li><a href="#choropleth-map-of-internet-usage">Choropleth map of internet usage</a></li>
<li><a href="#two-maps-in-print-composer">Two maps in Print Composer</a></li>
<li><a href="#addendum-editing-tables-in-sql">Addendum: Editing tables in SQL</a>

<ul>
<li><a href="#creating-a-new-table-from-an-sql-query">Creating a new table from an SQL Query</a>

<ul>
<li><a href="#postgis">PostGIS</a></li>
<li><a href="#spatialite">SpatiaLite</a></li>
<li><a href="#add-new-field-to-table-in-spatialite">Add new field to table in SpatiaLite</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#resources-and-references">Resources and references</a></li>
</ul>


<!-- /MarkdownTOC -->


<p><a name="overview"></a></p>

<h1>Overview</h1>

<p>In module 01 we learned how to build a spatial database and create a simple map in QGIS. In this module, we explore a common analysis technique using quantitative, numerical data: the choropleth map.</p>

<p>Throughout this module, we'll be:</p>

<ul>
<li>loading CSV data into QGIS</li>
<li>reprojecting the map into an equal-area projection using SpatiaLite</li>
<li>performing a tabular join and calculate geometry in SQL</li>
<li>creating a classed choropleth map</li>
<li>adjusting data types and symbology "on the fly"</li>
<li>Creating a multi-map layout</li>
</ul>


<p><a name="data-files"></a></p>

<h1>Data files</h1>

<ul>
<li><em>internet_users.zip</em> contains Internet usage rates by country code and additional metadata files. It doesn't include geometry to draw the country. We will obtain country polygons separately.</li>
<li>Download Shapefiles from <a href="http://www.naturalearthdata.com">Natural Earth</a></li>
</ul>


<p><a name="natural-earth-data"></a></p>

<h1>Natural Earth Data</h1>

<p>Our goal here is to make a world map of current countries and color them according to a particular quantitative data attribute (in the example below, the population density and internet usage for each country). We first need to obtain some geometries of world countries with which to make our map.</p>

<p>While there are many sources for these across the web, a good option is always <a href="http://www.naturalearthdata.com/">Natural Earth</a>. Natural Earth offers a variety of generalized layer with attributes for free download and use, which describe both cultural and physical data at one of three scales.</p>

<p><img src="module-02-graphics/natural-earth.png" title="Natural Earth" alt="Natural Earth downloads options" /> <br/>
Figure 01: Natural Earth downloads options</p>

<p>For our purposes here we want to choose "Cultural" data from the "Medium scale data," which has been optimized for 1:50,000,000 scale maps. As we saw in the previous lesson, Kentucky at 1:1,000,000 scale fits comfortably on a map page that's 30" wide and 15" tall. How large of a page would the whole world fit at 1:50 million-scale?</p>

<p><img src="module-02-graphics/select-medium-cultural.png" alt="Selecting Cultural Medium scale data" /> <br/>
Figure 02: Selecting Cultural Medium scale data</p>

<p>On the <a href="http://www.naturalearthdata.com/downloads/50m-cultural-vectors/">50 meter Cultural Vectors download page</a> we are provided a variety of download options, including national administration boundaries, country-level states and provinces, point-level airports and ports, and polygons of urban areas. If you're curious, Natural Earth has built a database of the vector layers and is offered as an <a href="http://naciscdn.org/naturalearth/packages/natural_earth_vector.sqlite.zip">SQLite database</a>. The raster data on Natural Earth, while not included in this database, is stunning and should be a primary resource for any continental-scale cartography and it's all free!</p>

<p>For this module, we're going to select "Download countries without boundary lakes" from the "Admin 0 - Countries" option. This option should prompt your web browser to download the shapefiles, bundled together in a zipped file named <em>ne_50m_admin_0_countries_lakes.zip</em>.</p>

<p>To make our map look a little more conventional, navigate to the "Physical" features and download the "Ocean" and "Graticule" at 10-degree interval. These layers will help us visualize map distortion later in the lesson while providing more detail for our map.</p>

<p><a name="spatial-database-option"></a></p>

<h1>Spatial database option</h1>

<p>If you are working in a spatial database, let's create it now and add the downloaded data. Create a new QGIS project space, i.e., a <em>module-02</em> folder and a new .qgs document. In QGIS's <strong>Browser Panel</strong> right-click on the <strong>SpatiaLite > Create database...</strong>, navigate to your project space, and save your database with an appropriate name:</p>

<p><img src="module-02-graphics/q01-add-database.png" alt="Add spatial database to project" />
Figure 03: Add spatial database to project</p>

<p>In PostGIS you can create new schema with DB Manager. A schema can be thought of as a separate workspace or folder within your database where spatial assets are stored. While you can use your <em>public</em> schema for your projects, a separate schema is good to organize your data:</p>

<p><img src="module-02-graphics/q37-add-schema.png" alt="Create new schema" />
Figure 04: Create new schema in DB Manager</p>

<p>If your new schema is named "module_02", then the syntax for calling a table outside the <em>public</em> schema is to prefix the table name with the schema name separated by a period:</p>

<pre><code>select
    *
from
    module_02.table_name
</code></pre>

<p>Using DB Manager, add the Natural Earth layers to your newly created database. Make sure you follow the steps we used in the previous lesson. Properly building a database is the key to start a GIS project. Don't worry about importing the internet usage data, yet. After import, you should have a database similar to:</p>

<p><img src="module-02-graphics/q02-new-database-layers.png" alt="New database with layers from Natural Earth" /> <br/>
Figure 05: New database with layers from Natural Earth</p>

<p><a name="example-sql-statements-for-this-lesson"></a></p>

<h2>Example SQL statements for this lesson</h2>

<p>Before we start executing SQL, let's find example statements we can use during the lesson. If you haven't changed table names, you should be able to copy these statements and paste them into DB Manager.</p>

<ul>
<li><a href="https://gist.github.com/boydx/4e74cbf9238fbb0ef63581e0af0969e2">PostGIS</a></li>
<li><a href="https://gist.github.com/boydx/20a0dfa13546cabcd607e7e1e9e10dd3">SpatiaLite</a></li>
</ul>


<p><a name="exploring-natural-earth-data-attributes"></a></p>

<h1>Exploring Natural Earth data attributes</h1>

<p>Once we have layers in our Layers Panel, let's inspect the attributes. We can see the familiar shapes of our Earthly landmasses, demarcated by nation-state borders. QGIS again automatically applies a random color to these polygons, which you can change in the Layer properties. I changed the white background to a slight gray at 85%.</p>

<p><img src="module-02-graphics/q03-new-map-styled.png" alt="Unprojected Natural Earth Admin 0 polygons within QGIS" /> <br/>
Figure 06: Unprojected (EPSG: 4326) Natural Earth layers within QGIS</p>

<p>Note that the graticule (lines of latitude and longitude) make nice little equally-sized squares all across the map. That's why we call this default projection for unprojected data an <a href="https://en.wikipedia.org/wiki/Equirectangular_projection">equirectangular projection</a>, also known as a "Plate Carre√©" projection. If you look at a globe, we know that lines of longitude converge at the poles. The equirectangular projection preserves neither correct shape nor correct area and should never be used other than to store data. We'll explore different projections in the following sections.</p>

<p>Equirectangular does have a surprising use in spherical photos as shown in this interactive world map, <a href="https://kuula.co/post/7fBMf">https://kuula.co/post/7fBMf</a>:</p>

<p><img src="module-02-graphics/q04-equirectagular.png" alt="Equirectangular projection as spherical photo" /> <br/>
Figure 07: An equirectangular projection can make a spherical photo in the VR world</p>

<p>Let's move onward to more closely inspect these data.</p>

<p><strong>Right-click</strong> the <em>ne_50m_admin_0_countries_lakes</em> layer and select <strong>Open Attribute Layer</strong>. You should now see the table of attributes:</p>

<p><img src="module-02-graphics/q38-open-attribute-table.png" alt="Table of attributes" /> <br/>
Figure 08: Inspecting attribute table</p>

<p>While some of these data attribute fields may not be immediately evident, we can recognize some of the potential value for us. Obviously, fields such as "sovereignty" and "admin" are the country names. We also see several fields that are codes used for individual countries: "sov_a3", "adm0_a3", "gu_a3", "su_a3", "brk_a3", "postal", "iso_a2", "iso_a3", "iso_n3", etc (some of these are internal administrative level  codes specifically used by Natural Earth and not assigned by the International Standards Organization or ISO).</p>

<p>These are nominal (i.e., categorical) data type attributes. The attributes also include numerous numerical and ordinal data types. For instance, there are population estimates and gross national product values. Left-justified fields are text fields and right-justified fields are numeric quantities. Not all numbers are qualities, e.g., zip codes. For further explanation read <a href="http://axismaps.github.io/thematic-cartography/articles/level_of_measurement.html">Level of Measurement: Nominal, Ordinal, and Numerical Data</a>. Understanding the data type is the first step in symbolizing your map features since certain color schemes apply to certain data types.</p>

<p>Sorting fields by quantity or alphabetically is easy. Clicking the field name in the attribute table will sort the table, e.g., you can sort countries by population estimate with the "pop_est" field.</p>

<p>Additionally, there are many other data fields of limited utility to us within this particular mapping process. However, a quick view of the <a href="http://www.naturalearthdata.com/forums/forum/natural-earth-map-data/">Natural Earth forum</a> can help decipher the field names. Since Shapefiles have a 10-character limit to the name of the field, they often have to be abbreviated.</p>

<p><a name="using-db-manager-to-inspect-attributes"></a></p>

<h1>Using DB Manager to inspect attributes</h1>

<p>If your data is in a spatial database, let's use DB Manager to explore some of the attribute data of our <em>ne_50m_admin_0_countries</em> layer. Open a <strong>SQL window</strong> in the DM Manager and <strong>Execute</strong> the following query:</p>

<pre><code>/* Let's first view our features */

select 
    *
from
    ne_50m_admin_0_countries_lakes
</code></pre>

<p>OK, let's select only those we need for our work:</p>

<pre><code>/* View only useful columns */

select 
    id, geom, name, mapcolor7, pop_est, gdp_md_est, iso_a3
from
    ne_50m_admin_0_countries_lakes
</code></pre>

<p>We should be familiar with the <em>id</em>, <em>geom</em>, and <em>name</em> fields. The <em>mapcolor7</em> is an attribute to symbolize countries by seven different colors so that we can more easily see variation. The <em>pop_est</em> is an estimation of population count. The <em>gdp_md_estimate</em> is the estimate of gross domestic production (GDP), an indicator of wealth. The <em>iso_a3</em> column is a three-character code used to uniquely identify countries and is a widely recognized system. We'll use this column to join attributes from the table with internet usage.</p>

<p>Which country is has the largest population and highest GDP? Let's sort with SQL:</p>

<pre><code>/* Rank by largest population */

select 
    id, geom, name, mapcolor7, pop_est, gdp_md_est, iso_a3
from
    ne_50m_admin_0_countries_lakes
order by
    pop_est desc --specify the sort field here
</code></pre>

<p>and</p>

<pre><code>/* Rank by highest GDP */

select 
    id, geom, name, mapcolor7, pop_est, gdp_md_est, iso_a3
from
    ne_50m_admin_0_countries_lakes
order by
    gdp_md_est desc --specify the sort field here
</code></pre>

<p>Enough putzing around with the attributes. With a good query executed in the DB Manager, <strong>Load as a new layer</strong> and call it "World countries" to QGIS and let's make some maps!</p>

<p><a name="thematic-map-color-schemes"></a></p>

<h1>Thematic map color schemes</h1>

<p>To symbolize a layer in QGIS, first, right-click on the <em>World countries</em> and choose <strong>Properties</strong> (we'll be using this procedure frequently to perform operations or analysis on data layers within QGIS).</p>

<p>Within the Layer Properties window that opens, select <strong>Style</strong> on the left-hand side, and then choose <strong>Categorized</strong>. Then use <strong>Column > <em>mapcolor7</em></strong> dropdown and <strong>Color ramp > Random colors</strong>.</p>

<p><img src="module-02-graphics/q05-mapcolor7.png" alt="Categorical thematic map" /> <br/>
Figure 09: Categorical thematic map with a random color scheme to show difference of type.</p>

<p>This color scheme is called a "nominal color scheme". We're coloring our countries to emphasize difference of type. It would not be appropriate to use a "sequential color scheme" (also called a "graduated color scheme") with this attribute since it would imply difference of magnitude. A "diverging color scheme" is also not appropriate for this data, since the numbers do not indicate a quantity and we have no meaningful statistics on this data, Look at <a href="http://www.axismaps.com/guide/color_schemes/">Axis maps color schemes for thematic maps</a>.</p>

<p>The <em>mapcolor7</em> attribute allows us to symbolize our country polygons so that no neighboring countries share the same color. What's the minimum number of colors that achieve this result? Take at look at the <a href="https://en.wikipedia.org/wiki/Four_color_theorem">four color map theorem</a>.</p>

<p><img src="module-02-graphics/q06-mapcolor7.png" alt="Categorical thematic map" /> <br/>
Figure 10: Nominal color scheme using the <em>mapcolor7</em> attribute. YES!</p>

<p><img src="module-02-graphics/q07-mapcolor7.png" alt="Categorical thematic map" /> <br/>
Figure 11: Sequential color scheme using the <em>mapcolor7</em> attribute. NO!</p>

<p>Let's find an attribute where we can use a graduated color scheme: <em>pop_est</em>. If you don't the field, then you might need to apply an expression casting it a real number. If you used DB Manager it could have loaded our SQL query with columns in the <em>TEXT</em> data type (except for the <em>INTEGER</em> <em>id</em> field). When we classify our field, we will need to cast the TEXT field to a numeric data type in order to use <strong>Graduated</strong> method of classification. We do that with an <strong>Expression</strong> applied to the column in the <strong>Style</strong> tab.</p>

<p><img src="module-02-graphics/q08-mapcolor7.png" alt="Numeric thematic map" /> <br/>
Figure 10: Sequential color scheme using the <em>Pop_est</em> attribute. Yes!</p>

<p>You won't be able to select the <em>pop_est</em> column without first applying an expression on your data:</p>

<p><img src="module-02-graphics/q09-mapcolor7.png" alt="Expression dialog" /> <br/>
Figure 12: Apply an expression that converts a TEXT field to a NUMERIC field</p>

<p>Just like we did with the <code>cast field as real</code> in SQL for the last lesson, this is QGIS's function to change data types temporarily so that we can sort and rank our features. The method of classifying our numeric attributes is the <a href="https://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization">Natural Breaks (Jenks)</a>.</p>

<p><img src="module-02-graphics/q10-pop_est.png" alt="Map of population count using a graduated color scheme" /> <br/>
Figure 13: Map of population count using a graduated color scheme</p>

<p>OK, this map is terrible!! Why? It's in the default equirectangular projection. Russia looks huge! So big! Let's discover a projection that preserves the proportional area so we can compare countries.</p>

<p><a name="projecting-the-map"></a></p>

<h2>Projecting the map</h2>

<p>As discussed in Module 01, making a map always involves distorting either the area or shape of the landmasses to "project" the roundish Earth on a flat surface (whether that's a printed map or your computer screen). When making a thematic map, it's important to choose a map projection that preserves the area across the map.</p>

<p>Within QGIS we can change the coordinate system used to draw the map by changing the  <strong>QGIS menu > Project > Project Properties > CRS</strong> (as discussed in Module 01, you'll want to ensure the "on-the-fly-projection" is enabled). This will change the CRS of the display while maintaining the layers' individual CRS. If want to permanently change the CRS of layer, your would right-click the layer and <strong>Save As...</strong> to a new file. The resulting dialog window gives options for specifying a new CRS.</p>

<p>Find <strong>Project > Project Properties > CRS</strong>. In the lower panel of the Coordinate Reference System Selector window, we have the option to change either the Geographic Coordinate Systems or the Projected Coordinate Systems.</p>

<p>As we can see, QGIS offers us numerous projections out of the box (you can also define your unique projection), some of these are suitable for mapping geographies at different map scales and purposes (i.e., do we want to preserve the area or shape of our features?). See <a href="http://docs.qgis.org/2.14/en/docs/gentle_gis_introduction/coordinate_reference_systems.html">Coorindate Reference Systems</a> for more guidance on how to choose appropriate projections for your project.</p>

<p>For this map, let's choose the Equal-Area Mollweide Projection. Note that it is sometimes easiest to search for a given projection within QGIS using the <a href="http://www.epsg.org/">EPSG code</a> (in this case EPSG: 54009).</p>

<p><img src="module-02-graphics/q11-crs.png" alt="Selecting equal area cylindrical projection" /> <br/>
Figure 14: Selecting equal area projection</p>

<p>Once the map is projected into the EPSG: 54009 CRS, we can compare the result with the "unprojected" equirectangular map (above).</p>

<p><img src="module-02-graphics/q12-map-54009.png" alt="GDP per capita map projected as equal-area cylindrical projection, ESPG: 3975" /> <br/>
Figure 15: World map projected as equal-area cylindrical projection</p>

<p>We can see that now the area of the landmasses is preserved, e.g., Greenland does not appear larger than Africa. The shapes of land masses are distorted, e.g., Greenland looks kinda 'funny').</p>

<p>There are other equal-area projections you may find suitable for world maps. Among these are the World Eckert VI (EPSG:54010) displayed here. Note how the inclusion of a graticule, also downloadable from Natural Earth, helps one see the angles by which the map is being distorted.</p>

<p><img src="module-02-graphics/world-ekert-vi-projection.png" alt="GDP per capita map projected as equal area World Eckert, ESPG: 54010" /> <br/>
Figure 16: GDP per capita map projected as equal area World Eckert VI, EPSG:54010</p>

<p>The World Bonne projection, EPSG:54024, is another good choice and makes the land masses appear a bit more "natural" in their shape.</p>

<p>A fun alternative is the World Bonne projection, EPSG:54024, though some audiences may find it difficult to concentrate on the information being displayed because of the uniqueness of the shape of the projected Earth:</p>

<p><img src="module-02-graphics/world-bonne-projection.png" alt="GDP per capita map projected as equal area World Bonne, ESPG: 54024" /> <br/>
Figure 17: GDP per capita map projected as equal area World Bone, EPSG:54024</p>

<p>If you find that a projection causes your geometry to look broken or fractured, you will need to create a new layer. Transform the layer to the new CRS using the right-click on the layer and <strong>Save As..</strong>  to new data.</p>

<p><a name="choropleth-map"></a></p>

<h1>Choropleth map</h1>

<p>Perhaps the most common type of thematic map is the choropleth, which we just made. These maps use enumeration units (a fancy term for polygons) such as states or counties to show the distribution of a particular phenomenon across the units. Choropleth maps have become the archetypal thematic map, particularly online. As the public has become accustomed to reading them (especially regarding "election maps"), mappers can assume these maps will be well understood (or, unfortunately, easily misunderstood). As a bonus, choropleths are relatively easy to make with desktop GIS programs like QGIS and web mapping libraries such as Leaflet, Mapbox and CARTO.</p>

<p>Choropleths are ideally used to map continuous areal (or area-based) phenomena and represent a statistical surface for enumeration units. However, as mappers, we often violate this principle. For example, it's common to use choropleth maps to symbolize population, even though the majority of people now live in dense cities. Choropleth maps also depict the data as if it changes abruptly at the borders of the enumeration unit. While this makes complete sense for something like county-level tax rates, the symbolization technique becomes problematic when applied to continuous phenomena, like the average elevation of a county.</p>

<p>At the most basic, a choropleth map symbology applies a sequential color scheme to symbolize the quantity of the desired variable for each enumeration unit on the map. How much of X is in Y? The goal of the choropleth, however, is to allow comparisons between different units. We should recognize that mapping raw counts present a problem; larger enumeration units can contain larger quantities of anything mappable. Raw counts or totals must be divided by another value (such as area) to create a rate, ratio, or density measure. This method is known as standardizing or normalizing the data, and it allows for the comparison of units of varying sizes.</p>

<p>This raw count vs. density measure is a bit of conundrum for a new mapper. Our first instinct is to map the raw count and it can make a useful map, depending on the variable. For example, it's nice to know the total population of a county. A more interesting map would be to show the density of that population (people per square mile), since that reflects a better sense of how people live in that county. Read more about <a href="http://axismaps.github.io/thematic-cartography/articles/choropleth.html">Choropleth Maps</a>.</p>

<p>Let's walk through the process of making a choropleth map using the data provided by Natural Earth (we intentionally saved the GDP and population estimates for this purpose). After that, we can repeat the process with data we wish to join to these country polygons to create our intended choropleth map of global Internet access.</p>

<p>OK, time to explore how we can make choropleth maps that normalize raw count variables, like population density.</p>

<p><a name="calculating-geometry-measures"></a></p>

<h2>Calculating geometry measures</h2>

<p>Let's take a look at the <em>pop_est</em> variable for each country and divide by the polygon area of each country. This measure would give population density. When we inspect the attributes, we find no column for area, so we'll need to calculate that geometry measurement.</p>

<p>The first step in any measurement is deciding which coordinate system to use and then modify our <strong>Project > Project Properties > CRS</strong> to that coordinate system. We have found that the World Mollweide EPSG: 54009 is a good equal-area CRS. Verify that the lower-righthand corner in QGIS says "EPSG: 54009 (OTF)" which means that the data is being projected on-the-fly to EPSG: 54009.</p>

<p>Let's <strong>Save As...</strong> to a new layer (right-click the layer in the Layers Panel) using the World Mollweide CRS:</p>

<p><img src="module-02-graphics/q39-save-to-new-table.png" alt="Save to new layer using the Project's CRS EPSG: 54009" /> <br/>
Figure 18: Save to new layer using the Project's CRS EPSG: 54009</p>

<p>Since we're using this layer for calculation and not for web mapping yet, we do not change the coordinate precision if you're saving as a GeoJSON. You can also save to a SpatiaLite layer (preferred on Linux). Once the layer is added to the Layers Panel, open the <strong>Field Calculator</strong>:</p>

<p><img src="module-02-graphics/q42-open-field-calculator.png" alt="Open Field Calculator" /> <br/>
Figure 18: Open Field Calculator</p>

<p>Since our linear unit in EPSG:54009 is meter, the area units are square meters, a very large number! This is the default setting, though it can be changed in <strong>Project > Project Properties > General</strong> settings. In the Field Calculator we can create a column called, "Area_sq_km" and calculate square kilometers, a simple unit conversion of dividing by a million (a million square meters in a square kilometer):</p>

<p><img src="module-02-graphics/q43-field-calculator.png" alt="Calculating area in the Field Calculator using the EPSG: 54009 CRS" /> <br/>
Figure 19: Calculating area in the Field Calculator using the EPSG: 54009 CRS</p>

<p>and using the expression:</p>

<pre><code>$area / 1000000
</code></pre>

<p>After the calculation open the layer's attribute table and verify that you have output. When we perform table calculations, the layer enters edit mode. We can toggle editing off and save our calculations by clicking the <strong>Pencil</strong> icon:</p>

<p><img src="module-02-graphics/q44-toggle-editing.png" alt="Saving our edits by toggle off edit mode" /> <br/>
Figure 20: Saving our edits by toggle off edit mode</p>

<p>We can also use a vector geoprocessing tool calculate geometry measures. Find the tool in the QGIS menu <strong>Vector > Geometry Tools > Export/Add geometry columns</strong>:</p>

<p><img src="module-02-graphics/q40-add-geometry-columns.png" alt="Adding geometry columns" /> <br/>
Figure 21: Adding geometry columns using the the Layer's CRS (EPSG: 54009)</p>

<p>This geoprocessing tool will reliable add geometry measurements and create a new layer. The parameters you need to modify is to select the <strong>Layer CRS</strong> for the geometry calculations. Note that the CRS is shown with layer name. You can save it to new SpatiaLite layer, GeoJSON, Shapefile, etc., but it is also fine to create a temporary layer. You can always <strong>Save As...</strong> to a new layer once the analysis is done. Your tool should look like:</p>

<p><img src="module-02-graphics/q41-add-geometry-columns.png" alt="Adding geometry columns" /> <br/>
Figure 22: Adding geometry columns using the the Project's CRS (EPSG: 54009)</p>

<p>The output columns are in the unit of the CRS, meter. If we use this tool, we will still need to use Field Calculator to convert to square kilometers.</p>

<p>This method of geometry calculation is fine, but you can do this without creating new layers or data. Explore the SQL option.</p>

<p><a name="calculating-geometry-measures-in-sql"></a></p>

<h3>Calculating geometry measures in SQL</h3>

<p>Let's take a look at the <em>pop_est</em> variable for each country and divide by the polygon area of each country. This measure would give population density. When we inspect the attributes, we find no column for area, so we'll need to calculate that geometry measurement.</p>

<p>Open DB Manager and execute the query we used earlier to sort by population:</p>

<pre><code>/* Rank by largest population */

select 
    id, geom, name, mapcolor7, pop_est, gdp_md_est, iso_a3
from
    ne_50m_admin_0_countries_lakes
order by
    pop_est desc --specify the sort field here
</code></pre>

<p>How can add a geometry measurement to our table? We can use SpatiaLite's <code>st_area(geom)</code>  function to calculate area, where <em>geom</em> is the field that contains geometry. When we use this function, we need always to be aware of the coordinate system units of our layer, which, in this case, are angular units, i.e., degrees.</p>

<pre><code>/* Rank by largest area in units of degrees??? */

select 
    id, geom, name, mapcolor7, pop_est, gdp_md_est, iso_a3,
    st_area(geom) as area_unknown_units
from
    ne_50m_admin_0_countries_lakes
order by
    area_unknown_units
    desc --specify the sort field here
</code></pre>

<p>Look at the output table and find the column <em>area_unknown_units</em>. Why are the values so small?</p>

<p><img src="module-02-graphics/q13-area-degrees.png" alt="Area calculated in ESPG: 4326" /> <br/>
Figure 23: Area calculated in ESPG: 4326</p>

<p>The SpatiaLite <code>st_area(geom)</code> function calculates the area in 2D regardless of units. Since the units are in EPSG: 4326 are decimal degrees, which have dimensions between 360 in width and 180 in height, the output is also small. A 2D area calculation with these dimensions result in an earth area of 64,800 units. Unfortunately, this is a meaningless measurement. If we wanted to inspect our coordinate values, we can use the <code>AsText(geom)</code> function to display them as a text field. For example, execute this SQL in DB Manager and expend the columns to read the contents:</p>

<pre><code>/* View coordinate values in geom field */

select 
    AsText(geom) as "Coordinates", 
    name
from
    ne_50m_admin_0_countries_lakes
</code></pre>

<p><img src="module-02-graphics/q14-coordinates-as-text.png" alt="Use AsTest(geom) to read coordinate values in geom field" />  <br/>
Figure 18: Use <code>AsTest(geom)</code> to read coordinate values in <em>geom</em> field</p>

<p>SpatiaLite's bigger buddy, PostGIS, will calculate area on a spheroid and output in square meters. We don't need to transform our CRS in that environment.</p>

<p>In order for SpatiaLite to calculate correct area, we'll need to project our layer to an equal-area CRS before calculating area measurements. We can use the <code>st_transform()</code> function to project our layer. We only need to know the field name that contains the geometry, i.e., the <em>geom</em> field, and the SRID of the target coordinate system. Let's practice some SQL queries to show how the <code>st_transform()</code> works.</p>

<pre><code>/* Transform geometry field to EPSG: 3975 */

select 
    st_transform(geom, 3975) as equal_area_geom,
    AsText(geom) as "Coordinates", 
    name
from
    ne_50m_admin_0_countries_lakes
</code></pre>

<p>Let's take a look at the output, which gives us two geometry fields, one as a BLOB and the other as TEXT. The <em>equal_area_geom</em> has units of meters since we projected the geometry to an equal-area projection called EPSG: 3975.</p>

<p><img src="module-02-graphics/q15-two-geoms.png" alt="Two geometry fields in different coordinate systems" />  <br/>
Figure 24: Two geometry fields in different coordinate systems</p>

<p>We can reveal the contents of the <em>equal_area_geom</em> field by nesting functions in SQL:</p>

<pre><code>/* Transform geometry field to EPSG: 3975 and display contents as text */

select 
    AsText(st_transform(geom, 3975)) as "Coordinates in EPSG: 3975",
    AsText(geom) as "Coordinates in EPSG: 4326", 
    name
from
    ne_50m_admin_0_countries_lakes
</code></pre>

<p>Look at the resulting columns:</p>

<p><img src="module-02-graphics/q16-two-geoms_as_text.png" alt="Nesting functions to show two different coordinate systems" /> <br/>
Figure 25: Nesting functions to show two different coordinate systems</p>

<p>If we observe the nesting function capability, it should be easy to see that we could transform and calculate area in the same step. Let's put it all together with the following SQL. Note that the linear unit of measure in EPSG: 3975 is meter. To convert square meters to square kilometers, we need to divide by 1,000,000 (without the thousand separators):</p>

<pre><code>/* Rank by largest area in units of square kilometers */

select 
    id, geom, name, mapcolor7, pop_est, gdp_md_est, iso_a3,
    st_area(st_transform(geom, 3975))/1000000 as "Area in square kilometers"

/* note that the linear unit of measure in EPSG: 3975 is meter. To convert sq m to sq km, we need to divide by 1,000,000 */

from
    ne_50m_admin_0_countries_lakes
order by
    "Area in square kilometers"
    desc 
</code></pre>

<p>Your successful query should look like:</p>

<p><img src="module-02-graphics/q17-area-measure-3975.png" alt="Transform and calculate area" /> <br/>
Figure 26: Transform and calculate area in a different coordinate system.</p>

<p>If you Google the areas of countries in square kilometers, you'll discover that these values are close but not exact. Why is that? Two main reasons. First, the shapes of the earth's landmasses is encoded at 1:50,000,000-scale resolution. The shape is imprecise so the measured area will also be imprecise. A second reason is that no one projected coordinate system can measure the globe accurately.</p>

<p><a name="adding-custom-projections-to-a-spatial-database"></a></p>

<h4>Adding custom projections to a spatial database</h4>

<p>In the previous section, we used the Equal-Area Mollweide Projection, <a href="http://www.epsg.io/54009">EPSG: 54009</a>. Unfortunately, this SRID isn't included in the default set of SpatiaLite projections. We can easily add new projections to our spatial database by using the <code>Insert</code> statement found at <a href="http://www.epsg.io/54009">http://www.epsg.org/54009</a>. If you copy the SQL definition text for PostGIS in the Export section, you can paste it into SpatiaLite and execute:</p>

<p><img src="module-02-graphics/q18-get-54009.png" alt="Copy SQL definition(PostGIS) at epsg.io/54009 and paste it into SpatiaLite" /> <br/>
Figure 27: Copy SQL definition(PostGIS) at epsg.io/54009 and paste it into SpatiaLite</p>

<p>The copied SQL gives us:</p>

<pre><code>INSERT into spatial_ref_sys 
    (srid, auth_name, auth_srid, proj4text, srtext)
values 
    ( 54009, 'ESRI', 54009, '+proj=moll +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs ', 'PROJCS["World_Mollweide",GEOGCS["GCS_WGS_1984",DATUM["WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]],PROJECTION["Mollweide"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",0],UNIT["Meter",1],AUTHORITY["EPSG","54009"]]');
</code></pre>

<p>Which will look like this in DB Manager:</p>

<p><img src="module-02-graphics/q19-get-54009.png" alt="Executing this SQL query will insert a new record in our spatial reference table, though nothing will be returned in the SQL window" /> <br/>
Figure 28: Executing this SQL query will insert a new record in our spatial reference table, though nothing will be returned in the SQL window</p>

<p>Note that you can only insert this record once, since we can't have duplicate SRIDs. If you changed the SRID to the large value to make it unique, you could create your own projections.</p>

<p>OK, let's put it together to find areas of countries in square kilometers in the Mollweide equal-area projection. Here's the SQL:</p>

<pre><code>/* Rank by largest area in units of square kilometers in Mollweide projection */

select 
    id, geom, name, mapcolor7, pop_est, gdp_md_est, iso_a3,
    st_area(st_transform(geom, 54009))/1000000 as "Area_in_sq_km"

/* note that the linear unit of measure in EPSG: 54009 is meter. To convert sq m to sq km, we need to divide by 1,000,000 */

from
    ne_50m_admin_0_countries_lakes
order by
    "Area_in_sq_km" desc 
</code></pre>

<p>Note that I added underscores to field names. If you have a successful query, let's <strong>Load as a new layer</strong> and start normalizing our raw count population field:</p>

<p><img src="module-02-graphics/q20-load-layer.png" alt="Load layer with area measurement" /> <br/>
Figure 29: Load layer with area measurement</p>

<p><a name="normalizing-by-polygon-area-to-create-the-choropleth-map"></a></p>

<h2>Normalizing by polygon area to create the choropleth map</h2>

<p>We now have a spatial layer with population as a raw count and a field with a measurement of area by country. Let's use our <strong>Layer Properties > Style</strong> tab to create a custom expression for <strong>Graduated</strong> symbology:</p>

<p>Use the <strong>Expression dialog</strong> like we did earlier to convert our TEXT fields to NUMERIC field types. You only need to do this if QGIS doesn't recognize the values as numeric. Then, use the division symbol <code>/</code> to divide population count by area:</p>

<pre><code>to_real(  "pop_est"  )  /  to_real(  "Area_in_sq_km" ) 
</code></pre>

<p>This is calculated "on the fly" just like our coordinate system. Your <strong>Styles</strong> panel should look like:</p>

<p><img src="module-02-graphics/q21-styles-legend.png" alt="Style panel for creating population density measure" /> <br/>
Figure 30: Style panel for creating population density measure</p>

<p>We used the "Quantile (Equal Count)" (<a href="https://www.youtube.com/watch?v=0ebL8OvG8Jc">nice video explanation from Benjamin Meader</a>) classification mode. Because the population density is highly skewed, using Natural Breaks would have most countries in the lowest classes. The Equal Count puts an equal number of countries in each class. Setting classification mode is an exploratory process. However, once you get a distribution that looks detailed, we can clean up the legend and make a finished map.</p>

<p><img src="module-02-graphics/q22-people-per-sq-km.png" alt="People per square kilometer by country" /> <br/>
Figure 31: People per square kilometer by country</p>

<p><a name="customizing-the-legend"></a></p>

<h2>Customizing the Legend</h2>

<p>The inclusion of a legend is important for the reader to interpret the symbology of a choropleth map. Within QGIS, we can add a legend using the Print Composer, as we did in Module 01.</p>

<p>Before we do that, however, let's take a moment to think about these values that we've calculated using <strong>Expression dialog</strong> window. We can see that initially simply divided our <code>to_real(  "pop_est"  )  /  to_real(  "Area_in_sq_km" )</code> values to get a range of values of people per square kilometer. Why is there a negative population? Three records have "-99" values, which means can't be determined. Right-click your and <strong>Open attribute table</strong> and then double-click the field <em>pop_est</em> to sort. You should see:</p>

<p><img src="module-02-graphics/q23-table-people-per-sq-km.png" alt="People per square kilometer by country" /> <br/>
Figure 32: Table for layer people per square kilometer by country</p>

<p>To fix this, we need only to manually adjust the actual values of the class breaks to be more rounded numbers. It may not seem very scientific to take the values that QGIS painfully produced through precise algorithms and just round them to other numbers as we see fit. Trust us, this is a perfectly acceptable cartographic practice. We've already seen how changing the mode of classification dramatically remakes the map. There are few hard and fast rules when it comes to these questions. Use your power as a cartographer thoughtfully, since you can significantly influence the interpretation of this map.</p>

<p>To alter your class breaks, just double-click the <strong>Values</strong> in your <strong>Style</strong> tab classification values. You'll need to also edit the corresponding <strong>Legend</strong> values:</p>

<p><img src="module-02-graphics/q24-table-people-per-sq-km.png" alt="Editing classification breaks" /> <br/>
Figure 33: Editing classification breaks</p>

<p>Let's take moment to discuss field "precision" in the context of the <strong>Style</strong> tab and legend. A numeric field's "precision" is the number of decimal places here. If you applied a negative precision, you are rounding to the number.</p>

<p><img src="module-02-graphics/q25-table-people-per-sq-km.png" alt="When you finish your style and legend, save the style" /> <br/>
Figure 34: When you finish your style and legend, save the style as a QGIS Layer Style file or in a database</p>

<p>When you have a map you like, create a new <strong>Print Composer</strong>, say 12" wide by 18" tall page size, and add this map and legend. Here might be what you create:</p>

<p><img src="module-02-graphics/q26-print-composer-map.png" alt="Creating a finished map in Print Composer" />  <br/>
Figure 35: Creating a finished map in Print Composer</p>

<p>In the <strong>Map 0 > Item Properties</strong> tab, check on <strong>Lock layers</strong> and <strong>Lock styles for layers</strong>. This creates a snapshot of our Map Canvas. Now we can alter layers in our <strong>Layers Panel</strong> to create additional maps to place in Print Composer.</p>

<p>We just walked through a foundational process for creating a choropleth map using QGIS. Before moving on to this week's lab challenge, let's bring in some tabular internet access data and join them to these country geometries.</p>

<p><a name="joining-tabular-data-to-natural-earth-geometry-data"></a></p>

<h1>Joining tabular data to Natural Earth geometry data</h1>

<p>We've acquired data about world internet access and we've need to make a choropleth map allowing a user to compare these rates. We can either keep the existing QGIS project file open to use in this next section, or we can save the current project and then save a new project (world internet access by country). Since we went through all the trouble of cleaning up the attribute table, we may as well just reuse this project instead of downloading new data.</p>

<p>First, let's take note of our data. We've been given a CSV plain text file (comma separated values) <em>internet_users.csv</em>, which is an edited version of the <em>API_IT.NET.USER.P2_DS2_en_csv_v2.csv</em> file. If we open this file within a code editor, we can quickly see this is a little dizzying.</p>

<p><strong>NOTE:</strong> We recommend using the <a href="https://www.openoffice.org/product/calc.html">OpenOffice Calc application</a> for editing CSV files. We can edit with a code editor, but it would take some clever find/replace and select techniques.</p>

<p>Upon inspecting the data encoded within the <em>internet_users.csv</em> file, the important things we want to take note of are:</p>

<ul>
<li>The first row is the column and every row there after is a record or feature</li>
<li>The column of Country Name (which we may wish to use later for labeling countries)</li>
<li>the column of Country Code (very important! which we'll use to match with our Natural Earth shapefile geometries)</li>
<li>the data columns for each year, the values of which we note appear to be already encoded as a percentage (therefore we won't need to standardize against a population or some other value)</li>
<li>Read the supplied metadata for more detail</li>
</ul>


<p>Also notice the <em>.csvt</em> file (e.g., named <em>internet_users.csvt</em> ) that defines the field data type for each field. This <em>.csvt</em> file must be a text file with only one line and defines the types for each column. They should be quoted and comma separated, e.g. "Integer","Real","String" for INTEGER, NUMERIC, and TEXT data type, respectively. The sequence should match the <em>.csv</em> field list.</p>

<p>Our goal to join this CSV data to our country layer geometries using the shared Country Code values. In GIS this is called performing a table or attribute join.</p>

<p>First, let's load the <em>internet_users.csv</em> via the QGIS menu <strong>Layer > Add Layer > Add Delimited Text Layer...</strong>:</p>

<p><img src="module-02-graphics/q45-add-layer.png" alt="Add Delimited Text Layer" /> <br/>
Figure 36: Add Delimited Text Layer</p>

<p>with the following option selected <strong>No Geometry</strong>:</p>

<p><img src="module-02-graphics/q46-import-csv.png" alt="Delimited text layer import options" /> <br/>
Figure 37: Delimited text layer import options</p>

<p>Our world country spatial layer and internet CSV table share a common field; the both have a country code in the same three-digit format, which are "Country_code" and "iso_a3". Access the properties of world country spatial layer and select the <strong>Joins</strong> panel. Select the join table and attributes to create the join:</p>

<p><img src="module-02-graphics/q47-join.png" alt="Attribute join in the layer properties dialog" /> <br/>
Figure 38: Attribute join in the layer properties dialog</p>

<p>Verify that you have a join in the attribute table. If all looks good, you can now map internet usage by country.</p>

<p><a name="making-joins-permanent-for-table-edits-and-calculations"></a></p>

<h3>Making joins permanent for table edits and calculations</h3>

<p>Joins are not permanent by default and are mainly used for symbolizing features. If you try to edit a joined table, e.g., creating a new field for area calculations, you will likely break the join. The easiest way to make the join permanent is to save the join layers to a new layer. Right-click the layer and <strong>Save As...</strong> to a new GeoJSON. If you wanted to only save subset of features (as required in the lab) you can run a <strong>Filter...</strong> before you save the layer.</p>

<p><a name="performing-the-join-in-sql"></a></p>

<h2>Performing the join in SQL</h2>

<p>Let's first import the text file into our spatial database using the <strong>Import</strong> dialog in DB Manager:</p>

<p><img src="module-02-graphics/q27-import-layer.png" alt="Find the CSV file using the Directory browser button in the Import dialog" /> <br/>
Figure 39: Find the CSV file using the Directory browser button in the Import dialog</p>

<p>Our country spatial layer and internet use CSV table share a common field; the both have a country code in the same three-digit format. We'll join these two tables using this common field or key. We have two main types of joins in SQLite-flavored SQL that we'll use:</p>

<ul>
<li>An inner join only includes matching records.</li>
<li>outer join includes all of the records from the spatial layer and those matching from the join table.</li>
</ul>


<p>The column names and tables we'll use are:</p>

<ul>
<li>"County Code" in <em>internet_users</em></li>
<li>"iso_a3" in <em>ne_50m_admin_0_countries_lakes</em></li>
</ul>


<p>An example in SQL would help. This is called a <em>Natural</em> or inner join:</p>

<pre><code>/* Join tables where records share the same attribute */

select * from 
    ne_50m_admin_0_countries_lakes, 
    internet_users
where 
    internet_users."Country Code" = ne_50m_admin_0_countries_lakes."iso_a3" 
</code></pre>

<p>Where records in both tables share the same value in these columns, their attributes are joined. 213 joins were produced in the output table. Let's do an outer join:</p>

<pre><code>/* Join tables where all records are output from the left-hand table
and only the matching records from the right-hand table */

select 
    * 
from
    ne_50m_admin_0_countries_lakes     --this is the left-hand table
left outer join 
    internet_users                     --this is the right-hand table
on 
    internet_users."Country code" = ne_50m_admin_0_countries_lakes."iso_a3" 
</code></pre>

<p>All records from the spatial layer, the first table listed is the left-hand table, are included in the join. Matching records in the right-hand table are included. We have 241 records output. That means 28 country codes don't match. Political geography is a volatile field of practice!</p>

<p>Let's create a layer for mapping Internet access for the year 2014 with the following SQL query:</p>

<pre><code>/* Internet usage for 2014 by country per 100 people ranked highest to lowest */

select 
    internet_users."2014",
    ne_50m_admin_0_countries_lakes."iso_a3",
    ne_50m_admin_0_countries_lakes."geom",
    ne_50m_admin_0_countries_lakes."id",
    ne_50m_admin_0_countries_lakes."name",
    ne_50m_admin_0_countries_lakes."pop_est",
    ne_50m_admin_0_countries_lakes."gdp_md_est"

from
    ne_50m_admin_0_countries_lakes     --this is the left-hand table
left outer join 
    internet_users                     --this is the right-hand table
on 
    internet_users."Country code" = ne_50m_admin_0_countries_lakes."iso_a3" 
order by
    internet_users."2014" DESC
</code></pre>

<p>And you should have this output:</p>

<p><img src="module-02-graphics/q28-internet-use.png/" alt="Joined table showing internet use in 2014 by country" />  <br/>
Figure 32: Joined table showing internet use in 2014 by country</p>

<p><a name="choropleth-map-of-internet-usage"></a></p>

<h1>Choropleth map of internet usage</h1>

<p>After you have a verified a successful join, add the layer to our <strong>Map Canvas</strong> and start styling it! Here's a styled layer:</p>

<p><img src="module-02-graphics/q31-new-layer.png/" alt="Internet use by country in 2014" />  <br/>
Figure 40: Internet use by country in 2014</p>

<p>Notice the <code>%</code> symbols in the <strong>Legend Format</strong> settings in the layer's <strong>Style</strong> tab. To the right it adds a percent sign. To the left, it denotes which how to display the class breaks in the legend with <code>%1</code> being the lower class break value and <code>%2</code> the upper class break value.</p>

<p><img src="module-02-graphics/q29-internet-use-style.png/" alt="Styling the internet use by country in 2014 layer" />  <br/>
Figure 41: Styling the internet use by country in 2014 layer</p>

<p>OK, let's finish our map by adding the new map in <strong>Print Composer</strong>.</p>

<p><a name="two-maps-in-print-composer"></a></p>

<h1>Two maps in Print Composer</h1>

<p>To finish our exercise, we need to add this new map and legend to our <strong>Print Composer</strong> layout. Since we have locked the styles for the previous <strong>Map Canvas</strong> map showing population density, let's add this new map and repeat the process:</p>

<p><img src="module-02-graphics/q30-add-new-map.png" alt="Adding a second map to our layout" /> <br/>
Figure 42: Adding a second map to our layout</p>

<p>This second map is called "Map 1" has a unique set of <strong>Item properties</strong>. If we want our maps to look the same, we'll need to ensure their scale match. In the lab, you'll add multiple maps to a page and will adjust the scale and rotation to make additional maps look good on the page.</p>

<p>Now let's finish up our map with title and metadata to complete our lesson. Since we're displaying a world map, scale bars and north arrows aren't necessary. In fact, a scale bar would be misleading since the earth is certainly not that much shorter between the poles than at the Equator.</p>

<p>An example of a finished map:</p>

<p><img src="module-02-graphics/Patterns_Pop_Density_Internet_Use_in_2014.png" alt="Patterns of Population Density and Internet Use in 2014" />  <br/>
Figure 43: Patterns of Population Density and Internet Use in 2014</p>

<p><a name="addendum-editing-tables-in-sql"></a></p>

<h1>Addendum: Editing tables in SQL</h1>

<p>So we have a nice map to share, but what if we wanted to share a spatial data for online mapping? This is part of Lab 02. We know we want to export to a GeoJSON, but the data types of our columns need to be explicitly defined as NUMERIC or TEXT, which are the only two types in GeoJSON. Any value enclosed in quotes is considered a TEXT type. As we have seen, we can easily cast and convert data types "on the fly" in QGIS and SpatiaLite. Let's outline a method that makes data types permanent and includes calculations and density measures</p>

<p><a name="creating-a-new-table-from-an-sql-query"></a></p>

<h2>Creating a new table from an SQL Query</h2>

<p>We have been asked to create a map of county population density map for Kentucky. We have two layers; a county polygon layer and a table of county population values. We will need to calculate both an area for the county and the population density measure. Can we do this in one step?</p>

<p><a name="postgis"></a></p>

<h3>PostGIS</h3>

<p>In PostGIS it's fairly easy to create a new table from a query. Look at the following example using the <code>CREATE TABLE ... AS</code> statement:</p>

<pre><code>
create table 
    kentucky_counties
as  

select 
    county_poly_layer.id,
    county_poly_layer.geom,
    "PopulationTable".fips, 
    "PopulationTable".county_name, 
    "PopulationTable".population_column,
    "PopulationTable".population_column / ((st_area(st_transform(county_poly_layer.geom,3089)))/2.788e+7) as pop_per_sq_mile 
        -- calculate pop density per square mile
        -- we can use scientific notation for large numbers in expressions
from
    county_poly_layer, "PopulationTable"
where
    county_poly_layer.geoid = "PopulationTable".fips
and
    "PopulationTable".state='KY' 
</code></pre>

<p>That's it! In one step you perform a join, calculate population density, and created a new layer.</p>

<p>Notice that table and field names that have capital letters need to enclosed in double quotes "". Now, look at the nested functions to calculate population density. Look at the innermost function and work out. We are doing steps in the following order:</p>

<ul>
<li>Projecting (transform) to a local coordinate system suitable for Kentucky</li>
<li>Calculating area (in sq ft from the CRS) and then dividing by 2.788e+7 (2.788 x 10^7 or 27,880,000 sq ft to a sq mi)</li>
<li>Divide the population field by this area calculation</li>
</ul>


<p>Now you just need to load the table into QGIS's Map Canvas and export as a GeoJSON with the minimum attributes and coordinate precision.</p>

<p><a name="spatialite"></a></p>

<h3>SpatiaLite</h3>

<p>In SpatiaLite we can't use the <code>CREATE TABLE</code> statement on layers with geometry fields (we'll add geometry columns in the next lesson). In this addendum we'll use the process of loading layers into new databases to make queries permanent, which we can then edit. Since SpatiaLite databases are very portable, this is a common procedure.</p>

<p>First, let's do the table table join to add attributes to a table with geometry:</p>

<pre><code>select 
    county_poly_layer.id,
    county_poly_layer.geom,
    population_table.fips, 
    population_table.county_name, 
    population_table.population_column

from
    county_poly_layer, population_table
where
    county_poly_layer.geoid = population_table.fips
and
    population_table.state='KY' 
</code></pre>

<p><strong>Load as new layer</strong> into QGIS. You map should look like this:</p>

<p><img src="module-02-graphics/q32-ky.png" alt="Kentucky county polygon layer" />  <br/>
Figure 37: Kentucky county polygon layer</p>

<p>with an attribute table:</p>

<p><img src="module-02-graphics/q33-ky-table.png" alt="Kentucky county polygon layer attribute table" />  <br/>
Figure 44: Kentucky county polygon layer attribute table</p>

<p>You might think you could use this table to calculate county areas and then a population density measure. Unfortunately, the table join prevents use from calculating or adding new fields. The execution would work without a notice or error, but the join gets mismatched and we're left with an invalid table. It's one of those GIS 'gotchas' and should always inspect and test your output before you claim that it's awesome.</p>

<p>We have an easy fix; import this virtual layer back into a <em>new</em> database using the DB Manager <strong>Import layer</strong> like we've done so many times before. This will make our join a permanent table that we can then edit freely. After import, inspect your table's <strong>General Info</strong> for the following:</p>

<p><img src="module-02-graphics/q34-new-ky-table.png" alt="new Kentucky county polygon layer table" /> <br/>
Figure 39: new Kentucky county polygon layer table with permanently joined data</p>

<p><a name="add-new-field-to-table-in-spatialite"></a></p>

<h3>Add new field to table in SpatiaLite</h3>

<p>As we have seen in SQL, we can create new calculated fields easily with SQL queries. Unfortunately, we can't easily control the data type with this method. It is problematic for exporting layers to other applications. Let's use the DB Manger's <strong>Edit Table</strong> dialogue to add a new field:</p>

<p><img src="module-02-graphics/q35-edit-table.png" alt="new Kentucky county polygon layer table" />  <br/>
Figure 45: Edit table to add a new field</p>

<p>Then, <strong>Add Column</strong> and add properties for the field. It needs to be a REAL data type and since we're exporting to GeoJSON we can have verbose field names. Try to add the unit of measure and topic, if possible.</p>

<p><img src="module-02-graphics/q36-add-field.png" alt="Add new column" />  <br/>
Figure 46: Add new column or field</p>

<p>Once completed, we go back to the SQL window and execute the command <code>Update</code> to calculate a table's field. Try following statement:</p>

<pre><code>update
    kentucky_counties
set
    "Pop per sq mi 2015" = 9/10
</code></pre>

<p>It outputs zero? SpatiaLite (and PostGIS) databases look at the data types of math inputs and outputs the lowest type, e.g., integer/integer will get an integer output, with truncation!
Now let's try:
<code>
update
    kentucky_counties
set
    "Pop per sq mi 2015" = 9/10.0
</code></p>

<p>Now that's better! OK, let's apply what we have learned so far and make population density measure on this table. Consider the following SQL:</p>

<pre><code>update
    kentucky_counties
set
    "Pop per sq mi 2015" = 
    round("Pop 2015"/(round((st_area(st_transform(geom,3089)))/2.788e+7)),2) 
    /* area derived from EPSG: 3089 (feet), scaled to sq mi, and the whole thing rounded to two digits */
</code></pre>

<p>Look at the nested functions. Look at the innermost function and work out. We are doing steps in the following order:</p>

<ul>
<li>Projecting (transform) to a local coordinate system suitable for Kentucky</li>
<li>Calculating area (in sq ft from the CRS) and then dividing by 2.788e+7 (2.788 x 10^7 or 27,880,000 sq ft to a sq mi)</li>
<li>Divide the population field by this area calculation</li>
<li>Round everything to decimal places.</li>
</ul>


<p>Now you just need to load the table into QGIS's Map Canvas and export as a GeoJSON with the minimum attributes and coordinate precision.</p>

<p>Note: If your table doesn't seem to update, then close and reopen DB Manager.</p>

<p><a name="resources-and-references"></a></p>

<h1>Resources and references</h1>

<ul>
<li><a href="http://www.naturalearthdata.com/">Natural Earth</a></li>
<li><a href="http://axismaps.github.io/thematic-cartography/articles/level_of_measurement.html">Level of Measurement: Nominal, Ordinal, and Numerical Data</a></li>
<li><a href="http://axismaps.github.io/thematic-cartography/articles/choropleth.html">Choropleth Maps</a></li>
<li><a href="http://data.worldbank.org/indicator/IT.NET.USER.P2">The World Bank Group: Internet Users</a></li>
</ul>


<!-- Highlight syntax for Mou.app, insert at the bottom of the markdown document  -->




<script src="https://yandex.st/highlightjs/7.3/highlight.min.js"></script>


<p><link rel="stylesheet" href="https://yandex.st/highlightjs/7.3/styles/github.min.css"></p>

<script>
  hljs.initHighlightingOnLoad();
</script>

</body>
</html>